<!--
  This file was generated by stitchmd. DO NOT EDIT.
  To make changes, edit the files in the "src" directory.
-->

<!-- markdownlint-disable MD033 -->

# Uber Go Style Guide

- [Introduction](#introduction)
- [Guidelines](#guidelines)
  - [Pointers to Interfaces](#pointers-to-interfaces)
  - [Verify Interface Compliance](#verify-interface-compliance)
  - [Receivers and Interfaces](#receivers-and-interfaces)
  - [Zero-value Mutexes are Valid](#zero-value-mutexes-are-valid)
  - [Copy Slices and Maps at Boundaries](#copy-slices-and-maps-at-boundaries)
  - [Defer to Clean Up](#defer-to-clean-up)
  - [Channel Size is One or None](#channel-size-is-one-or-none)
  - [Start Enums at One](#start-enums-at-one)
  - [Use `"time"` to handle time](#use-time-to-handle-time)
  - [Errors](#errors)
    - [Error Types](#error-types)
    - [Error Wrapping](#error-wrapping)
    - [Error Naming](#error-naming)
    - [Handle Errors Once](#handle-errors-once)
  - [Handle Type Assertion Failures](#handle-type-assertion-failures)
  - [Don't Panic](#dont-panic)
  - [Use go.uber.org/atomic](#use-gouberorgatomic)
  - [Avoid Mutable Globals](#avoid-mutable-globals)
  - [Avoid Embedding Types in Public Structs](#avoid-embedding-types-in-public-structs)
  - [Avoid Using Built-In Names](#avoid-using-built-in-names)
  - [Avoid `init()`](#avoid-init)
  - [Exit in Main](#exit-in-main)
    - [Exit Once](#exit-once)
  - [Use field tags in marshaled structs](#use-field-tags-in-marshaled-structs)
  - [Don't fire-and-forget goroutines](#dont-fire-and-forget-goroutines)
    - [Wait for goroutines to exit](#wait-for-goroutines-to-exit)
    - [No goroutines in `init()`](#no-goroutines-in-init)
- [Performance](#performance)
  - [Prefer strconv over fmt](#prefer-strconv-over-fmt)
  - [Avoid repeated string-to-byte conversions](#avoid-repeated-string-to-byte-conversions)
  - [Prefer Specifying Container Capacity](#prefer-specifying-container-capacity)
- [Style](#style)
  - [Avoid overly long lines](#avoid-overly-long-lines)
  - [Be Consistent](#be-consistent)
  - [Group Similar Declarations](#group-similar-declarations)
  - [Import Group Ordering](#import-group-ordering)
  - [Package Names](#package-names)
  - [Function Names](#function-names)
  - [Import Aliasing](#import-aliasing)
  - [Function Grouping and Ordering](#function-grouping-and-ordering)
  - [Reduce Nesting](#reduce-nesting)
  - [Unnecessary Else](#unnecessary-else)
  - [Top-level Variable Declarations](#top-level-variable-declarations)
  - [Prefix Unexported Globals with _](#prefix-unexported-globals-with-_)
  - [Embedding in Structs](#embedding-in-structs)
  - [Local Variable Declarations](#local-variable-declarations)
  - [nil is a valid slice](#nil-is-a-valid-slice)
  - [Reduce Scope of Variables](#reduce-scope-of-variables)
  - [Avoid Naked Parameters](#avoid-naked-parameters)
  - [Use Raw String Literals to Avoid Escaping](#use-raw-string-literals-to-avoid-escaping)
  - [Initializing Structs](#initializing-structs)
    - [Use Field Names to Initialize Structs](#use-field-names-to-initialize-structs)
    - [Omit Zero Value Fields in Structs](#omit-zero-value-fields-in-structs)
    - [Use `var` for Zero Value Structs](#use-var-for-zero-value-structs)
    - [Initializing Struct References](#initializing-struct-references)
  - [Initializing Maps](#initializing-maps)
  - [Format Strings outside Printf](#format-strings-outside-printf)
  - [Naming Printf-style Functions](#naming-printf-style-functions)
- [Patterns](#patterns)
  - [Test Tables](#test-tables)
  - [Functional Options](#functional-options)
- [Linting](#linting)

## Introduction

Style (สไตล์) คือชุดของแนวทางปฏิบัติที่ใช้กำหนดรูปแบบการเขียนโค้ดของเรา

คำว่า style อาจฟังดูคลาดเคลื่อนอยู่บ้าง เพราะแนวทางปฏิบัติเหล่านี้ไม่ได้ครอบคลุมแค่เรื่องการจัดรูปแบบของไฟล์โค้ดเท่านั้น — ซึ่ง gofmt เป็นตัวที่จัดการเรื่องนี้ให้อยู่แล้ว

เป้าหมายของคู่มือนี้คือการจัดการกับความซับซ้อน โดยอธิบายรายละเอียดของสิ่งที่ควรทำและไม่ควรทำในการเขียนโค้ดภาษา Go ที่ Uber

กฎเหล่านี้มีไว้เพื่อช่วยให้ codebase สามารถจัดการได้ง่าย และในขณะเดียวกันก็ยังเปิดโอกาสให้วิศวกรสามารถใช้ฟีเจอร์ต่าง ๆ ของภาษา Go ได้อย่างมีประสิทธิภาพ

คู่มือนี้ถูกสร้างขึ้นครั้งแรกโดย [Prashant Varanasi](https://github.com/prashantv) และ [Simon Newton](https://github.com/nomis52) โดยมีวัตถุประสงค์เพื่อช่วยให้เพื่อนร่วมงานบางคนเรียนรู้การใช้ภาษา Go ได้อย่างรวดเร็ว

ตลอดหลายปีที่ผ่านมา คู่มือนี้ได้รับการปรับปรุงเพิ่มเติมตามข้อเสนอแนะจากผู้อื่น

เอกสารนี้บันทึกแนวทางปฏิบัติตามแบบ idiomatic ของภาษา Go ที่เราใช้กันที่ Uber

หลายข้อในนี้เป็นแนวทางทั่วไปของภาษา Go ส่วนบางข้อก็ขยายจากแหล่งข้อมูลภายนอก เช่น:
1. [Effective Go](https://go.dev/doc/effective_go)
2. [Go Common Mistakes](https://go.dev/wiki/CommonMistakes)
3. [Go Code Review Comments](https://go.dev/wiki/CodeReviewComments)

เราออกแบบตัวอย่างโค้ดในคู่มือนี้ให้สามารถใช้งานได้กับเวอร์ชันรองล่าสุด 2 รุ่นของภาษา Go [releases](https://go.dev/doc/devel/release)

โค้ดทั้งหมดควรจะไม่มีข้อผิดพลาดเมื่อรันผ่าน `golint` และ `go vet`

เราขอแนะนำให้ตั้งค่า editor ของคุณให้สามารถ:

- เรียกใช้ `goimports` เมื่อบันทึกไฟล์
- รัน `golint` และ `go vet` เพื่อตรวจสอบข้อผิดพลาด

คุณสามารถดูข้อมูลเกี่ยวกับการรองรับเครื่องมือของ Go ใน editor ได้ที่:
https://go.dev/wiki/IDEsAndTextEditorPlugins

## Guidelines

### Pointers to Interfaces

คุณแทบจะไม่เคยจำเป็นต้องใช้ พอยเตอร์ที่ชี้ไปยัง interface เลย โดยปกติควรส่งค่า interface เป็นแบบ value มากกว่า — เพราะข้อมูลภายในยังสามารถเป็นพอยเตอร์ได้อยู่แล้ว

Interface ประกอบด้วย 2 ส่วนหลัก:
1.	พอยเตอร์ที่ชี้ไปยังข้อมูลที่เฉพาะกับชนิดของ type (สามารถนึกภาพว่าเป็น “type”)
2.	พอยเตอร์ของข้อมูล — ถ้าข้อมูลที่เก็บไว้เป็นพอยเตอร์ จะเก็บไว้โดยตรง
      แต่ถ้าเป็นค่า (value) จะเก็บเป็นพอยเตอร์ที่ชี้ไปยังค่านั้นอีกที

ถ้าคุณต้องการให้ method ของ interface สามารถแก้ไขข้อมูลภายในได้จริง ๆ
คุณจะต้องใช้พอยเตอร์กับข้อมูลภายในนั้น — ไม่ใช่ ใช้พอยเตอร์กับตัว interface

### Verify Interface Compliance

ควรตรวจสอบการ implement interface ให้ถูกต้องตั้งแต่ compile time ตามความเหมาะสม ซึ่งรวมถึงกรณีต่อไปนี้

- type ที่เป็น exported ซึ่งจำเป็นต้อง implement interface ตาม API contract
- type ที่เป็น exported หรือ unexported ซึ่งอยู่ในกลุ่มของหลาย ๆ type ที่ implement interface เดียวกัน
- กรณีอื่น ๆ ที่การไม่ implement interface อย่างถูกต้องจะส่งผลกระทบต่อผู้ใช้งาน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Handler struct {
  // ...
}



func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  ...
}
```

</td><td>

```go
type Handler struct {
  // ...
}

var _ http.Handler = (*Handler)(nil)

func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
```

</td></tr>
</tbody></table>

คำสั่ง `var _ http.Handler = (*Handler)(nil)`
ใช้เพื่อยืนยันว่า `*Handler` implement interface `http.Handler` อย่างถูกต้อง หากในอนาคต `*Handler` ไม่สอดคล้องกับ interface นี้ คำสั่งนี้จะทำให้เกิด error ตอน compile

ค่าทางฝั่งขวาของ assignment ควรเป็นค่าเริ่มต้น (zero value) ของ type ที่จะใช้ตรวจสอบ
ซึ่งถ้าเป็น pointer, slice หรือ map — ค่านั้นคือ `nil`
แต่ถ้าเป็น struct ธรรมดา ควรใช้ struct ว่าง เช่น `struct{}{}`

```go
type LogHandler struct {
  h   http.Handler
  log *zap.Logger
}

var _ http.Handler = LogHandler{}

func (h LogHandler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
```

### Receivers and Interfaces

เมธอดที่มี value receiver สามารถถูกเรียกใช้งานได้ทั้งกับตัวแปรแบบค่า (value) และพอยเตอร์ (pointer)
ในขณะที่เมธอดที่มี pointer receiver จะสามารถถูกเรียกได้เฉพาะกับพอยเตอร์เท่านั้น หรือกับ [addressable values](https://go.dev/ref/spec#Method_values) (เช่น ตัวแปรที่สามารถนำไปอ้างอิงด้วย & ได้)


```go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

// เราไม่สามารถใช้พอยเตอร์ชี้ไปยังค่าที่เก็บอยู่ใน map ได้ เพราะค่าที่อยู่ใน map 
// ไม่ใช่ addressable values (ไม่สามารถใช้ & เพื่ออ้างอิงตำแหน่งหน่วยความจำของมันได้)
sVals := map[int]S{1: {"A"}}

// อย่างไรก็ตาม เราสามารถเรียกใช้เมธอด Read กับค่าที่อยู่ใน map ได้
// เพราะ Read มี value receiver ซึ่งไม่ต้องการให้ค่าที่ใช้งานเป็น addressable
sVals[1].Read()

// แต่เรา ไม่สามารถเรียกใช้เมธอด Write กับค่าที่อยู่ใน map ได้
// เนื่องจาก Write มี pointer receiver และเราไม่สามารถสร้างพอยเตอร์จากค่าที่อยู่ใน map ได้โดยตรง
//
//  sVals[1].Write("test")

sPtrs := map[int]*S{1: {"A"}}

// หาก map เก็บ พอยเตอร์ เป็นค่า เช่น map[int]*SomeType
// เราจะสามารถเรียกใช้ได้ทั้ง Read และ Write เพราะ พอยเตอร์เป็น addressable โดยธรรมชาติ
sPtrs[1].Read()
sPtrs[1].Write("test")
```

ในทำนองเดียวกัน interface ก็สามารถถูก implement โดย pointer ได้
แม้ว่าเมธอดใน interface นั้นจะมี value receiver ก็ตาม

```go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &S1{}
s2Val := S2{}
s2Ptr := &S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

// The following doesn't compile, since s2Val is a value, and there is no value receiver for f.
//   i = s2Val
```

บทความ Effective Go มีคำอธิบายที่ดีเกี่ยวกับเรื่อง [Pointers vs. Values](https://go.dev/doc/effective_go#pointers_vs_values)

### Zero-value Mutexes are Valid

ค่าเริ่มต้น (zero value) ของ `sync.Mutex` และ `sync.RWMutex` สามารถใช้งานได้เลยทันที
ดังนั้นคุณแทบไม่จำเป็นต้องใช้ pointer ไปยัง mutex เหล่านี้เลย

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
mu := new(sync.Mutex)
mu.Lock()
```

</td><td>

```go
var mu sync.Mutex
mu.Lock()
```

</td></tr>
</tbody></table>

ถ้าคุณใช้งาน struct ผ่าน pointer
mutex ควรเป็นฟิลด์แบบไม่ใช้พอยเตอร์ (non-pointer) ภายใน struct นั้น

อย่า embed mutex ลงไปใน struct โดยตรง ถึงแม้ว่า struct นั้นจะไม่ได้เป็น exported ก็ตาม

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type SMap struct {
  sync.Mutex

  data map[string]string
}

func NewSMap() *SMap {
  return &SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.Lock()
  defer m.Unlock()

  return m.data[k]
}
```

</td><td>

```go
type SMap struct {
  mu sync.Mutex

  data map[string]string
}

func NewSMap() *SMap {
  return &SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.mu.Lock()
  defer m.mu.Unlock()

  return m.data[k]
}
```

</td></tr>

<tr><td>

ฟิลด์ `Mutex` รวมถึงเมธอด `Lock` และ `Unlock` ได้กลายเป็นส่วนหนึ่งของ API ที่ถูก export โดยไม่ได้ตั้งใจ ของ `SMap`
</td><td>

mutex และ method อย่าง `Lock()` / `Unlock()` ถือเป็น รายละเอียดภายใน (implementation detail) ของ `SMap`
ซึ่งหมายความว่า คนที่เรียกใช้งาน (caller) ไม่ควรต้องรู้ หรือยุ่งกับมันโดยตรง

</td></tr>
</tbody></table>

### Copy Slices and Maps at Boundaries

slice และ map มีพอยเตอร์ ที่ชี้ไปยังข้อมูลภายใน (underlying data)
ดังนั้นควรระวังกรณีที่จำเป็นต้อง คัดลอกข้อมูล เพื่อป้องกันการเปลี่ยนแปลงที่ไม่ตั้งใจ

#### Receiving Slices and Maps

อย่าลืมว่า ถ้าคุณรับ slice หรือ map มาเป็น argument แล้วเก็บ reference ไว้
ผู้เรียก (caller) ยังสามารถเปลี่ยนแปลงข้อมูลนั้นได้ภายหลัง

<table>
<thead><tr><th>Bad</th> <th>Good</th></tr></thead>
<tbody>
<tr>
<td>

```go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = trips
}

trips := ...
d1.SetTrips(trips)

// Did you mean to modify d1.trips?
trips[0] = ...
```

</td>
<td>

```go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = make([]Trip, len(trips))
  copy(d.trips, trips)
}

trips := ...
d1.SetTrips(trips)

// We can now modify trips[0] without affecting d1.trips.
trips[0] = ...
```

</td>
</tr>

</tbody>
</table>

#### Returning Slices and Maps

ในทำนองเดียวกัน อย่าคืนค่า map หรือ slice โดยตรง จากภายใน struct
โดยเฉพาะเมื่อมีการใช้ mutex ป้องกัน — เพราะข้อมูลเหล่านั้นอาจถูกแก้ไขจากภายนอกโดยไม่ตั้งใจ
ควรคืนเป็นสำเนา (copy) แทน เพื่อปกป้องสถานะภายในของระบบ

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Stats struct {
  mu sync.Mutex
  counters map[string]int
}

// Snapshot returns the current stats.
func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  return s.counters
}

// ตอนนี้ snapshot ไม่ถูกป้องกันอีกแล้ว ใครเข้ามาแก้พร้อมกันก็เกิด race ได้
snapshot := stats.Snapshot()
```

</td><td>

```go
type Stats struct {
  mu sync.Mutex
  counters map[string]int
}

func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  result := make(map[string]int, len(s.counters))
  for k, v := range s.counters {
    result[k] = v
  }
  return result
}

// snapshot ตอนนี้เป็นสำเนา (copy) ปลอดภัย ไม่มี race
snapshot := stats.Snapshot()
```

</td></tr>
</tbody></table>

### Defer to Clean Up

ใช้ defer เพื่อจัดการ clean up กับ resource ที่ต้องถูกคืนค่า เช่นไฟล์ หรือ lock ต่าง ๆ

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
p.Lock()
if p.count < 10 {
  p.Unlock()
  return p.count
}

p.count++
newCount := p.count
p.Unlock()

return newCount

// มีโอกาศที่ทำให้เราลืมเรียก Unlock() ได้ง่าย เมื่อมีหลายจุดที่ return
```

</td><td>

```go
p.Lock()
defer p.Unlock()

if p.count < 10 {
  return p.count
}

p.count++
return p.count

// อ่านง่าย ปลอดภัยกว่า
```

</td></tr>
</tbody></table>

defer มีค่า overhead (ต้นทุนการทำงานเพิ่มเติม) ที่น้อยมาก — จึงควรหลีกเลี่ยงการใช้ แต่จะใช้เฉพาะเมื่อคุณสามารถพิสูจน์ได้ว่าฟังก์ชันของคุณทำงานในระดับ nanoseconds เท่านั้น

```text
กล่าวคือ ถ้าฟังก์ชันเร็วมาก ๆ ในระดับ nano-second และถูกเรียกซ้ำบ่อย ๆ (high-performance critical path)
การไม่ใช้ defer อาจช่วยให้ประหยัด performance ได้เล็กน้อย
```
แต่ในกรณีทั่วไป
* การใช้ `defer` ช่วยให้โค้ด อ่านง่ายขึ้น และลดความผิดพลาดในการลืม cleanup
* โดยเฉพาะในเมธอดที่มีความซับซ้อนมากกว่าแค่การเข้าถึงหน่วยความจำ (memory access)
  เช่น มีการประมวลผล หรือเงื่อนไขหลายชั้น

### Channel Size is One or None

โดยทั่วไป channel ควรมีขนาด (buffer size) เป็น 1 หรือ ไม่มี buffer เลย (unbuffered)
ตามค่าเริ่มต้น channel จะเป็นแบบ unbuffered ซึ่งหมายความว่ามีขนาดเท่ากับ ศูนย์ (0)
หากคุณจะใช้ channel ที่มีขนาดมากกว่านั้น จำเป็นต้องพิจารณาให้ละเอียดและรอบคอบ (subject to a high level of scrutiny)
ให้พิจารณาคำถามเหล่านี้
* ขนาดของ channel ที่คุณเลือก มีเหตุผลอย่างไร?
* มีอะไรรับประกันว่า channel จะไม่เต็ม เมื่อระบบทำงานภายใต้โหลดสูง?
* ถ้า channel เต็มแล้ว จะเกิดอะไรขึ้น? เช่น จะ block ฝั่งเขียน (writer) หรือไม่?

**สรุป:**

การตั้งขนาด channel โดยไม่มีเหตุผลรองรับชัดเจน อาจนำไปสู่ bug ยาก ๆ ที่ตามหายากมากใน production
ขนาด 1 หรือ unbuffered มักจะปลอดภัยและเข้าใจง่ายกว่า เว้นแต่คุณจะรู้ชัดว่าเหตุผลของ buffer ที่มากกว่านั้นคืออะไร.


<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// คิดเอาเองว่าพอแน่ ๆ แต่ไม่มีเหตุผลรองรับ
c := make(chan int, 64)
```

</td><td>

```go
// Buffered channel ขนาด 1
c := make(chan int, 1) // or
// หรือใช้แบบไม่มี buffer (synchronous channel)
c := make(chan int)
```

</td></tr>
</tbody></table>

### Start Enums at One

วิธีมาตรฐานในการสร้าง Enum ใน Go คือ  สร้าง ชนิดข้อมูลแบบกำหนดเอง (custom type) ตามด้วยการประกาศกลุ่ม `const` ที่ใช้ `iota` เพื่อเพิ่มค่าตัวเลขอัตโนมัติ
แต่เนื่องจากตัวแปรใน Go มี ค่าเริ่มต้นเป็นศูนย์ (0) จึง ควรหลีกเลี่ยงการเริ่ม enum จากค่า 0 เว้นแต่คุณตั้งใจให้ 0 มีความหมายพิเศษ

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Operation int

const (
  Add Operation = iota      // 0
  Subtract                  // 1
  Multiply                  // 2
)

// ปัญหา: Add มีค่าเท่ากับ 0 ซึ่งอาจเกิดความสับสนหรือ bug ได้หากลืมกำหนดค่าให้ตัวแปร
```

</td><td>

```go
type Operation int

const (
  Add Operation = iota + 1  // 1
  Subtract                  // 2
  Multiply                  // 3
)

// ข้อดี: เริ่มจาก 1 ช่วยหลีกเลี่ยงการใช้ค่าดีฟอลต์ (0) โดยไม่ได้ตั้งใจ
```

</td></tr>
</tbody></table>

แม้จะมีคำแนะนำทั่วไปว่า ควรหลีกเลี่ยงการใช้ 0 เป็นค่าของ enum 
แต่ก็มีบางกรณีที่ การใช้ค่า 0 เป็นค่าเริ่มต้นถือว่าเหมาะสม
เช่น เมื่อค่าเริ่มต้นนั้นตรงกับพฤติกรรมที่ต้องการให้ระบบใช้งานโดยดีฟอลต์

```go
type LogOutput int

const (
  LogToStdout LogOutput = iota  // 0
  LogToFile                     // 1
  LogToRemote                   // 2
)

// LogToStdout มีค่า 0 ซึ่งเป็นค่าดีฟอลต์ของชนิด LogOutput
```

<!-- TODO: section on String methods for enums -->

### Use `"time"` to handle time

เวลา (time) เป็นเรื่องซับซ้อน และมี ความเข้าใจผิดที่มักเกิดขึ้นบ่อย เช่น

1. หนึ่งวันมี 24 ชั่วโมง
2. หนึ่งชั่วโมงมี 60 นาที
3. หนึ่งสัปดาห์มี 7 วัน
4. หนึ่งปีมี 365 วัน
5. [And a lot more](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time)

ตัวอย่างเช่น **ข้อ 1** หมายความว่า การบวกเวลา 24 ชั่วโมงเข้าไป อาจ ไม่ได้ผลลัพธ์เป็นวันใหม่ตามปฏิทิน เสมอไป (เช่น ช่วงเปลี่ยนเวลาใน daylight saving)

ควรใช้แพ็กเกจ [`"time"`](https://pkg.go.dev/time) ของ Go ในการจัดการกับเวลาเสมอ
เพราะมันช่วยจัดการกับความซับซ้อนเหล่านี้ได้อย่าง ปลอดภัยและแม่นยำ มากกว่าเขียนเองหรือใช้การคำนวณโดยตรง

#### Use `time.Time` for instants of time

ให้ใช้ [`time.Time`](https://pkg.go.dev/time#Time) และใช้ เมธอดของ `time.Time` เช่น Before, After, Equal, Add, Sub
แทนที่จะใช้เลขจำนวนเต็ม (int) ซึ่งอาจก่อให้เกิดข้อผิดพลาดหรือความเข้าใจผิดได้ง่าย

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func isActive(now, start, stop int) bool {
  return start <= now && now < stop
}
```

</td><td>

```go
func isActive(now, start, stop time.Time) bool {
  return (start.Before(now) || start.Equal(now)) && now.Before(stop)
}
```

</td></tr>
</tbody></table>

#### Use `time.Duration` for periods of time

เมื่อจัดการกับ ช่วงเวลา (periods of time) เช่น ความยาวของเวลา หรือระยะเวลาที่ผ่านไป
ให้ใช้ [`time.Duration`](https://pkg.go.dev/time#Duration) เสมอ

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func poll(delay int) {
  for {
    // ...
    time.Sleep(time.Duration(delay) * time.Millisecond)
  }
}

poll(10) // was it seconds or milliseconds?
```

</td><td>

```go
func poll(delay time.Duration) {
  for {
    // ...
    time.Sleep(delay)
  }
}

poll(10*time.Second)
```

</td></tr>
</tbody></table>

กลับไปที่ตัวอย่างก่อนหน้าเรื่องการ บวกเวลา 24 ชั่วโมง กับเวลาหนึ่งจุด (time instant) — วิธีที่เราจะใช้ในการบวกเวลานั้นขึ้นอยู่กับ “เจตนา” ของเรา
* ถ้าเราต้องการ เวลาเดิมของวันถัดไปในปฏิทิน (เช่น ตอนนี้คือ 9 โมงเช้าวันนี้ → อยากได้ 9 โมงเช้าวันพรุ่งนี้) ให้ใช้ [`Time.AddDate`](https://pkg.go.dev/time#Time.AddDate)
* แต่ถ้าเราต้องการ เวลาที่ห่างจากเดิมไป 24 ชั่วโมงจริง ๆ (นับตามชั่วโมง ไม่ใช่วันปฏิทิน) ให้ใช้ [`Time.Add`](https://pkg.go.dev/time#Time.Add)

```go
newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)
maybeNewDay := t.Add(24 * time.Hour)
```

#### Use `time.Time` and `time.Duration` with external systems

ควรใช้ `time.Time` และ `time.Duration` เมื่อต้องสื่อสารกับระบบภายนอก ถ้าเป็นไปได้ เช่น


- Command-line flags: แพ็กเกจ [`flag`](https://pkg.go.dev/flag) รองรับ `time.Duration` ผ่านฟังก์ชัน
  [`time.ParseDuration`](https://pkg.go.dev/time#ParseDuration)
- JSON: แพ็กเกจ [`encoding/json`](https://pkg.go.dev/encoding/json) รองรับการเข้ารหัส `time.Time` เป็น string ตาม [RFC 3339](https://tools.ietf.org/html/rfc3339)
  ผ่านเมท็อด [`UnmarshalJSON`](https://pkg.go.dev/time#Time.UnmarshalJSON)
- SQL: แพ็กเกจ [`database/sql`](https://pkg.go.dev/database/sql) รองรับการ map คอลัมน์ชนิด `DATETIME` หรือ `TIMESTAMP`
  ให้กลายเป็น time.Time ได้ (ขึ้นอยู่กับว่า driver รองรับหรือไม่)
- YAML: แพ็กเกจ [`gopkg.in/yaml.v2`](https://pkg.go.dev/gopkg.in/yaml.v2) รองรับ `time.Time` ในรูปแบบ string ตาม [RFC 3339](https://tools.ietf.org/html/rfc3339)
  และ `time.Duration` ผ่าน `time.ParseDuration`

แต่ในกรณีที่ ไม่สามารถใช้ `time.Duration` ได้โดยตรง (เช่น JSON ไม่รองรับ time.Duration)
ควรใช้ `int` หรือ `float64` และตั้งชื่อฟิลด์ ให้ระบุหน่วยไว้ด้วย เพื่อป้องกันความสับสน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// {"interval": 2}
type Config struct {
  Interval int `json:"interval"` // ไม่รู้ว่า 2 อะไร? วินาที? นาที?
}
```

</td><td>

```go
// {"intervalMillis": 2000}
type Config struct {
  IntervalMillis int `json:"intervalMillis"` // ชัดเจนว่าเป็นมิลลิวินาที
}
```

</td></tr>
</tbody></table>

เมื่อไม่สามารถใช้ `time.Time` ได้ในการสื่อสารกับระบบภายนอก หากไม่สามารถใช้ `time.Time` ได้ และไม่มีข้อตกลงเฉพาะอื่นไว้ล่วงหน้า ให้ใช้ `string` และจัดรูปแบบเวลาเป็นไปตาม [RFC 3339](https://tools.ietf.org/html/rfc3339)
* รูปแบบนี้เป็นค่าเริ่มต้นของเมท็อด [`Time.UnmarshalText`](https://pkg.go.dev/time#Time.UnmarshalText)
* สามารถใช้งานร่วมกับ `Time.Format` และ `time.Parse` ได้โดยใช้คงที่ [`time.RFC3339`](https://pkg.go.dev/time#RFC3339)

แม้ว่าส่วนใหญ่จะไม่มีปัญหาในทางปฏิบัติ แต่ควรทราบว่าแพ็กเกจ `"time"` ของ Go
* ไม่รองรับการ parse เวลาที่มี leap second (วินาทีพิเศษที่เพิ่มเข้ามาในบางปี) ดูรายละเอียดที่ issue [#8728](https://github.com/golang/go/issues/8728)
* ไม่รวม leap second ในการคำนวณเวลา เช่น การลบเวลาสองจุด จะไม่รวมวินาทีพิเศษที่อาจเกิดขึ้นระหว่างสองเวลานั้น ดูรายละเอียดที่ issue [#15190](https://github.com/golang/go/issues/15190)

### Errors

#### Error Types

การประกาศ error ใน Go มีหลายวิธีให้เลือกใช้ก่อนเลือกวิธีที่เหมาะสมกับกรณีของคุณ ควรพิจารณาคำถามเหล่านี้ก่อน

- ผู้เรียก (caller) จำเป็นต้องตรวจสอบประเภทของ error เพื่อจัดการกับมันหรือไม่? ถ้าใช่ ควรซซัปพอร์ตการใช้งาน [`errors.Is`](https://pkg.go.dev/errors#Is) หรือ [`errors.As`](https://pkg.go.dev/errors#As)
  ด้วยการประกาศตัวแปร error ไว้ระดับบน (top-level error variable) หรือใช้ custom error type
- ข้อความของ error เป็นข้อความตายตัว (static) หรือมีข้อมูลบริบทแบบ dynamic? ถ้าเป็น ข้อความตายตัว ใช้ [`errors.New`](https://pkg.go.dev/errors#New) ได้ ถ้าเป็น ข้อความที่ต้องใส่ข้อมูลเพิ่มเติม เช่น ตัวแปรหรือ context ควรใช้
  [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf) หรือสร้าง custom error type
- เรากำลังส่งต่อ error จากฟังก์ชันข้างล่าง (downstream function) หรือไม่? ถ้าใช่ ดูหัวข้อถัดไปเกี่ยวกับ การห่อ error [error wrapping](#error-wrapping)

| Error matching? | Error Message | Guidance                                                           |
|-----------------|---------------|--------------------------------------------------------------------|
| No              | static        | [`errors.New`](https://pkg.go.dev/errors#New)                      |
| No              | dynamic       | [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf)                      |
| Yes             | static        | top-level `var` with [`errors.New`](https://pkg.go.dev/errors#New) |
| Yes             | dynamic       | custom `error` type                                                |

ตัวอย่างเช่น
ใช้ [`errors.New`](https://pkg.go.dev/errors#New) เมื่อคุณต้องการสร้าง error ที่มีข้อความคงที่ (static string) หากผู้เรียก (caller) จำเป็นต้องดักและจัดการกับ error นี้
ให้ export error นี้เป็นตัวแปร (ประกาศไว้ระดับ package) เพื่อให้สามารถใช้ `errors.Is` ตรวจสอบได้

<table>
<thead><tr><th>No error matching</th><th>Error matching</th></tr></thead>
<tbody>
<tr><td>

```go
// package foo

func Open() error {
  return errors.New("could not open")
}

// package bar

if err := foo.Open(); err != nil {
  // Can't handle the error.
  panic("unknown error")
}
```

</td><td>

```go
// package foo

var ErrCouldNotOpen = errors.New("could not open")

func Open() error {
  return ErrCouldNotOpen
}

// package bar

if err := foo.Open(); err != nil {
  if errors.Is(err, foo.ErrCouldNotOpen) {
    // handle the error
  } else {
    panic("unknown error")
  }
}
```

</td></tr>
</tbody></table>

หาก error มี ข้อความแบบ dynamic
* ถ้า ไม่จำเป็นต้องดักชนิดของ error: ใช้ [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf)
* ถ้า ต้องการให้ caller ดักและจัดการ error เฉพาะประเภท: สร้าง custom error type

<table>
<thead><tr><th>No error matching</th><th>Error matching</th></tr></thead>
<tbody>
<tr><td>

```go
// package foo

func Open(file string) error {
  return fmt.Errorf("file %q not found", file)
}

// package bar

if err := foo.Open("testfile.txt"); err != nil {
  // Can't handle the error.
  panic("unknown error")
}
```

</td><td>

```go
// package foo

type NotFoundError struct {
  File string
}

func (e *NotFoundError) Error() string {
  return fmt.Sprintf("file %q not found", e.File)
}

func Open(file string) error {
  return &NotFoundError{File: file}
}


// package bar

if err := foo.Open("testfile.txt"); err != nil {
  var notFound *NotFoundError
  if errors.As(err, &notFound) {
    // ดักได้ว่าเป็น NotFoundError
  } else {
    panic("unknown error")
  }
}
```

</td></tr>
</tbody></table>

เมื่อคุณ export error (เช่น `var ErrSomething = errors.New("...")` หรือ `type SomeError struct {...})` ตัวแปรหรือ type นั้นจะสามารถเข้าถึงได้จากภายนอก package — ซึ่งหมายความว่าโค้ดอื่นที่ import package นี้อาจพึ่งพา error เหล่านี้ ทำให้การเปลี่ยนแปลงภายหลังต้องทำอย่างระมัดระวัง เพราะจะมีผลกับผู้ใช้ package ของคุณด้วย (เช่น การลบหรือเปลี่ยน behavior ของ error เหล่านั้นอาจทำให้โค้ดของคนอื่นพัง)

#### Error Wrapping

เมื่อเรียกฟังก์ชันแล้วเกิด error ขึ้น มีตัวเลือกหลัก ๆ 3 วิธีในการ propagate (ส่งต่อ) error เหล่านั้นออกไป:

- คืนค่า error ต้นฉบับแบบไม่เปลี่ยนแปลง
- เพิ่ม context ด้วย `fmt.Errorf` โดยใช้ `%w` (สำหรับการ wrap)
- เพิ่ม context ด้วย `fmt.Errorf` โดยใช้ `%v` (ไม่สามารถตรวจจับชนิดเดิมได้)

กรณีที่ควรคืนค่า error ต้นฉบับแบบไม่เปลี่ยนแปลง (return err ตรง ๆ)
หากไม่มีข้อมูลเพิ่มเติมที่ต้องการใส่เพิ่มใน error — ควรคืน error เดิมแบบ as-is เพื่อรักษาชนิดและข้อความของ error เดิมไว้
วิธีนี้เหมาะกับกรณีที่ข้อความ error จากต้นทาง (เช่น error จาก library หรือ function ด้านใน) มีข้อมูลเพียงพอสำหรับการแกะรอยและเข้าใจต้นตอของปัญหาอยู่แล้ว

ถ้าไม่สามารถคืน error ต้นฉบับแบบเดิมได้ — ควรเพิ่ม context (บริบท) ให้กับข้อความ error เพื่อให้เข้าใจสาเหตุได้ง่ายขึ้น
แทนที่จะได้ error ที่คลุมเครือ ตัวอย่างเช่นอย่างเช่น "connection refused" ควรแสดงข้อความที่มีบริบทมากขึ้น เช่น "call service foo: connection refused"

ให้ใช้ `fmt.Errorf` เพื่อ เพิ่มบริบท (context) ให้กับ error ที่เกิดขึ้น โดยเลือกใช้ `%w` หรือ `%v` ตามวัตถุประสงค์ของการ "ดักจับ" error ภายหลัง:

- `%w` — ใช้เมื่อผู้เรียกควรเข้าถึง error ต้นฉบับได้ `%w` เป็นตัวเลือก เริ่มต้นที่ดี สำหรับการ wrap error ส่วนใหญ่ ช่วยให้สามารถใช้ `errors.Is()` หรือ `errors.As()` ดักจับ error ดั้งเดิมได้ภายหลัง แต่ควรระวังว่า ผู้ใช้ function อาจเริ่มพึ่งพาพฤติกรรมนี้ หากคุณเผยแพร่ error นั้นแบบ public หากคุณ wrap ด้วย `%w` และใช้ error แบบมี type หรือเป็น `var` ที่รู้จัก — ควร เขียนเอกสารให้ชัดเจน (function contract) และ เขียน test รองรับ
- `%v` — ใช้เมื่อไม่ต้องการให้ผู้เรียกเข้าถึง error ต้นฉบับ ทำให้ error ต้นฉบับ ถูกซ่อนไว้ (obfuscate) ผู้เรียก ไม่สามารถ ใช้ `errors.Is` หรือ `errors.As` ตรวจจับได้ หากต้องการ เปลี่ยนกลับมาใช้ `%w` ในภายหลังก็สามารถทำได้ง่าย

เมื่อเพิ่มบริบท (context) ให้กับ error ที่ return กลับ ควรเขียนให้ กระชับ โดย หลีกเลี่ยงคำอย่าง “failed to” ซึ่งมักจะระบุสิ่งที่เห็นได้ชัดอยู่แล้ว และเมื่อ error ถูกส่งผ่านขึ้นมาหลายชั้น คำพวกนี้จะสะสมจนอ่านยาก:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "failed to create new store: %w", err)
}
```

</td><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "new store: %w", err)
}
```

</td></tr><tr><td>

```plain
failed to x: failed to y: failed to create new store: the error
```

</td><td>

```plain
x: y: new store: the error
```

</td></tr>
</tbody></table>

อย่างไรก็ตาม เมื่อส่ง error ไปยังระบบอื่น (เช่นระบบ logging หรือ monitoring), ควรทำให้ ชัดเจนว่าเป็นข้อความ error — ตัวอย่างเช่น
* ใส่ tag ว่า err หรือ error
* หรือใช้ prefix อย่างเช่น "Failed" ใน log message

ดูเพิ่มเติม [Don't just check errors, handle them gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully).

#### Error Naming

สำหรับค่าประเภท error ที่เก็บเป็น ตัวแปร global (ระดับ package), ควรตั้งชื่อตามหลักต่อไปนี้:
* ใช้ คำนำหน้า Err สำหรับตัวแปรที่ exported (ตัวแปรที่ขึ้นต้นด้วยตัวพิมพ์ใหญ่ และสามารถใช้งานนอกแพ็กเกจได้)
* ใช้ คำนำหน้า err สำหรับตัวแปรที่ unexported (ตัวแปรที่ขึ้นต้นด้วยตัวพิมพ์เล็ก ใช้งานได้เฉพาะในแพ็กเกจ)
แนวทางนี้ สำคัญกว่า แนวทางทั่วไปที่ว่า [Prefix Unexported Globals with _](#prefix-unexported-globals-with-_)

```go
var (
  // error เหล่านี้เป็น exported — ให้ใช้ prefix `Err`
  // เพื่อให้ผู้ใช้สามารถตรวจสอบ error ด้วย errors.Is ได้

  ErrBrokenLink = errors.New("link is broken")
  ErrCouldNotOpen = errors.New("could not open")

  // error นี้ไม่ export — ใช้ prefix `err`
  // เพราะไม่อยากให้กลายเป็นส่วนหนึ่งของ public API
  // แต่ยังใช้ตรวจสอบกับ errors.Is ได้ภายในแพ็กเกจ

  errNotFound = errors.New("not found")
)
```

สำหรับ custom error types (ชนิด error ที่เราสร้างเอง), ควรตั้งชื่อด้วย คำนำหน้า ชื่อ + คำต่อท้ายว่า Error เพื่อให้สื่อชัดเจนว่าเป็นประเภทของ error
* หากต้องการ export ชนิด error นี้ (ให้คนใช้งานจากภายนอกตรวจจับได้ด้วย errors.As) → ตั้งชื่อขึ้นต้นด้วยตัวพิมพ์ใหญ่ และลงท้ายด้วย Error
* ถ้าใช้เฉพาะใน package และ ไม่อยากให้เป็น public API → ขึ้นต้นด้วยตัวพิมพ์เล็ก แต่ยังคงใช้ Error เป็น suffix

```go
// Exported custom error type — ชื่อขึ้นต้นด้วยตัวพิมพ์ใหญ่ + ลงท้ายด้วย Error
// เพื่อให้ผู้ใช้สามารถดักจับด้วย errors.As ได้

type NotFoundError struct {
  File string
}

func (e *NotFoundError) Error() string {
  return fmt.Sprintf("file %q not found", e.File)
}

// Unexported custom error type — ชื่อขึ้นต้นด้วยตัวพิมพ์เล็ก + ลงท้ายด้วย Error
// ใช้ภายในแพ็กเกจเท่านั้น แต่ยังสามารถใช้ errors.As ตรวจจับได้

type resolveError struct {
  Path string
}

func (e *resolveError) Error() string {
  return fmt.Sprintf("resolve %q", e.Path)
}
```

#### Handle Errors Once

เมื่อฟังก์ชันหนึ่ง (caller) เรียกใช้งานอีกฟังก์ชัน (callee) แล้วได้ error กลับมา —
caller สามารถจัดการ error นั้นได้หลายวิธี ขึ้นอยู่กับว่า caller รู้ข้อมูลเกี่ยวกับ error นั้นมากแค่ไหน

วิธีที่นิยมใช้ ได้แก่ (แต่ไม่จำกัดแค่นี้):

- ถ้า callee มีการระบุ contract ไว้ชัดเจนว่าอาจ return error แบบใด
  → caller ควรใช้ `errors.Is` หรือ `errors.As` เพื่อ match กับ error ที่ระบุไว้ และจัดการแต่ละกรณีให้เหมาะสม
- ถ้า error นั้นสามารถกู้ได้ (recoverable) → ก็อาจแค่ log ไว้ แล้วทำงานต่อไปในโหมด degraded ได้
- ถ้า error นั้นเป็นเงื่อนไขความล้มเหลวเฉพาะในโดเมนของระบบ → อาจแปลงเป็น error แบบใหม่ที่นิยามไว้ชัดเจน (well-defined) แล้ว return กลับไป
- หรืออาจเลือก return error เดิมกลับไป (จะห่อหุ้มไว้ด้วย error [wrapped](#error-wrapping) หรือไม่ก็ได้)

อย่างไรก็ตาม ไม่ว่าจะเลือกจัดการ error แบบไหน ควรจัดการแต่ละครั้งเพียงครั้งเดียวเท่านั้น (handle once)
ช่น: ไม่ควร log error แล้ว return ต่อขึ้นไป เพราะ ผู้เรียกถัดไป (upstream caller) อาจต้องการจัดการ error นั้นด้วยเช่นกัน
→ การ log ซ้ำหลายรอบจะทำให้เกิด log ซ้ำซ้อน (duplicate log) และทำให้ trace ยากขึ้น

ตัวอย่างเช่น ลองพิจารณากรณีต่าง ๆ ต่อไปนี้:

<table>
<thead><tr><th>Description</th><th>Code</th></tr></thead>
<tbody>
<tr><td>

**Bad**: Log error แล้ว return error ซ้ำ

ฟังก์ชันที่อยู่สูงขึ้นไปใน call stack ก็มักจะจัดการ error นั้นเหมือนกัน (เช่น log อีกที)
การทำแบบนี้จะทำให้เกิด “ข้อความ log ที่เกินจำเป็น” ใน log จำนวนมาก โดยไม่มีประโยชน์จริง

</td><td>

```go
u, err := getUser(id)
if err != nil {
  // BAD: See description
  log.Printf("Could not get user %q: %v", id, err)
  return err
}
```

</td></tr>
<tr><td>

**Good**: Wrap แล้ว return error

ฟังก์ชันที่อยู่สูงขึ้นใน call stack จะเป็นผู้จัดการ error ต่อ การใช้ `%w` ใน `fmt.Errorf` จะช่วยให้ caller สามารถตรวจสอบประเภทของ error ได้ ผ่าน `errors.Is` หรือ `errors.As` ถ้าจำเป็น

</td><td>

```go
u, err := getUser(id)
if err != nil {
  return fmt.Errorf("get user %q: %w", id, err)
}
```

</td></tr>
<tr><td>

**Good**: Log แล้ว degrade gracefully

หาก operation นั้นไม่จำเป็นถึงขั้นต้องล้มเหลวทั้งระบบ
เราสามารถเลือก “ดัก” error ไว้ พร้อมกับแสดงผลหรือทำงานต่อในรูปแบบที่ลดระดับคุณภาพลง
แต่ยังให้ระบบทำงานต่อได้ โดยไม่พังทั้งหมด

</td><td>

```go
if err := emitMetrics(); err != nil {
  // ถ้า emitMetrics() เกิด error ก็ไม่ควรให้แอปพังหรือหยุดทำงาน
  log.Printf("Could not emit metrics: %v", err)
}

```

</td></tr>
<tr><td>

**Good**: ดักจับ error แล้ว degrade gracefully

ถ้า callee ระบุ error แบบเฉพาะเจาะจงใน contract ไว้
และ error นั้นสามารถกู้ได้ (recoverable)
ให้ตรวจสอบ (match) กับ error กรณีนั้น และจัดการแบบ degrade gracefully
ส่วนกรณีอื่น ๆ ให้ wrap error แล้ว return กลับไป

</td><td>

```go
tz, err := getUserTimeZone(id)
if err != nil {
  if errors.Is(err, ErrUserNotFound) {
    // User doesn't exist. Use UTC.
    tz = time.UTC
  } else {
    return fmt.Errorf("get user %q: %w", id, err)
  }
}
```

</td></tr>
</tbody></table>

### Handle Type Assertion Failures

การใช้ [type assertion](https://go.dev/ref/spec#Type_assertions) แบบคืนค่าเดียวจะทำให้เกิด panic หากชนิดไม่ตรง
ดังนั้นควรใช้รูปแบบ “comma ok” เสมอ (รูปแบบที่คืนค่ามาสองตัว: ค่าและตัวบอกความถูกต้อง)

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
t := i.(string)
```

</td><td>

```go
t, ok := i.(string)
if !ok {
  // handle the error gracefully
}
```

</td></tr>
</tbody></table>

<!-- TODO: There are a few situations where the single assignment form is
fine. -->

### Don't Panic

โค้ดที่รันใน production ควรหลีกเลี่ยงการใช้ panic เพราะ panic เป็นสาเหตุสำคัญของ [cascading failures](https://en.wikipedia.org/wiki/Cascading_failure) — ความล้มเหลวที่ลุกลามไปยังระบบอื่น ๆ
หากเกิดข้อผิดพลาด ให้คืนค่าเป็น error แล้วปล่อยให้ caller เป็นผู้ตัดสินใจว่าจะจัดการอย่างไร

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func run(args []string) {
  if len(args) == 0 {
    panic("an argument is required")
  }
  // ...
}

func main() {
  run(os.Args[1:])
}
```

</td><td>

```go
func run(args []string) error {
  if len(args) == 0 {
    return errors.New("an argument is required")
  }
  // ...
  return nil
}

func main() {
  if err := run(os.Args[1:]); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

</td></tr>
</tbody></table>

การใช้ panic/recover ไม่ใช่ วิธีในการจัดการข้อผิดพลาด (error handling strategy)
โปรแกรมควรใช้ panic เฉพาะในกรณีที่ไม่สามารถกู้คืนได้จริง ๆ เท่านั้น เช่น การ dereference ตัวแปรที่เป็น nil

```go
var _statusTemplate = template.Must(template.New("name").Parse("_statusHTML"))
```

แม้แต่ในการเขียนเทสต์ ก็ไม่ควรใช้ panic
ควรใช้ `t.Fatal` หรือ `t.FailNow` เพื่อให้ Go testing framework
ระบุสถานะของเทสต์ว่า “ล้มเหลว” ได้อย่างถูกต้อง

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func TestFoo(t *testing.T)

f, err := os.CreateTemp("", "test")
if err != nil {
  panic("failed to set up test")
}
```

</td><td>

```go
// func TestFoo(t *testing.T)

f, err := os.CreateTemp("", "test")
if err != nil {
  t.Fatal("failed to set up test")
}
```

</td></tr>
</tbody></table>

### Use go.uber.org/atomic

การทำ atomic operation ด้วยแพ็กเกจ [sync/atomic](https://pkg.go.dev/sync/atomic) จะทำงานกับ type standard เช่น int32, int64 โดยตรง
ซึ่งทำให้ ง่ายต่อการลืม ว่าต้องใช้ฟังก์ชัน atomic เพื่ออ่านหรือเขียนค่าตัวแปรเหล่านั้น

[go.uber.org/atomic](https://pkg.go.dev/go.uber.org/atomic) ช่วยเพิ่ม ความปลอดภัยของชนิดข้อมูล (type safety) ให้กับการทำงานแบบ atomic
โดยการ ซ่อนชนิดข้อมูลระดับล่าง (underlying type) ไม่ให้ผู้ใช้เข้าถึงโดยตรง

นอกจากนี้ยังมี type ที่ใช้งานสะดวก เช่น atomic.Bool สำหรับจัดการค่าบูลีนในรูปแบบ atomic ได้ง่ายขึ้นอีกด้วย

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type foo struct {
  running int32  // atomic
}

func (f* foo) start() {
  if atomic.SwapInt32(&f.running, 1) == 1 {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running == 1  // race!
}
```

</td><td>

```go
type foo struct {
  running atomic.Bool
}

func (f *foo) start() {
  if f.running.Swap(true) {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running.Load()
}
```

</td></tr>
</tbody></table>

### Avoid Mutable Globals

หลีกเลี่ยงการเปลี่ยนแปลงค่าของตัวแปร global (mutating global variables)
ให้เลือกใช้ dependency injection แทน

หลักการนี้ใช้ได้กับทั้ง ตัวชี้ไปยังฟังก์ชัน (function pointers) รวมถึง ค่าประเภทอื่น ๆ ด้วย

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// sign.go

var _timeNow = time.Now

func sign(msg string) string {
  now := _timeNow()
  return signWithTime(msg, now)
}
```

</td><td>

```go
// sign.go

type signer struct {
  now func() time.Time
}

func newSigner() *signer {
  return &signer{
    now: time.Now,
  }
}

func (s *signer) Sign(msg string) string {
  now := s.now()
  return signWithTime(msg, now)
}
```

</td></tr>
<tr><td>

```go
// sign_test.go

func TestSign(t *testing.T) {
  oldTimeNow := _timeNow
  _timeNow = func() time.Time {
    return someFixedTime
  }
  defer func() { _timeNow = oldTimeNow }()

  assert.Equal(t, want, sign(give))
}
```

</td><td>

```go
// sign_test.go

func TestSigner(t *testing.T) {
  s := newSigner()
  s.now = func() time.Time {
    return someFixedTime
  }

  assert.Equal(t, want, s.Sign(give))
}
```

</td></tr>
</tbody></table>

### Avoid Embedding Types in Public Structs

การฝัง type แบบนี้จะทำให้ รายละเอียดของ implementation รั่วออกไป,
ขัดขวางการพัฒนา/เปลี่ยนแปลง type ในอนาคต, และ ทำให้เอกสารอ่านยาก

สมมุติว่าคุณมีการสร้าง list หลายประเภท โดยใช้ type ที่แชร์ร่วมกันชื่อว่า `AbstractList`
อย่า embed `AbstractList` ลงใน struct ที่เป็น concrete list โดยตรง
แต่ให้เลือกวิธีการเขียน method ด้วยตัวเองใน concrete list
เพื่อให้แต่ละ method delegate (เรียกใช้งาน) ไปยัง `AbstractList` แทน

```go
type AbstractList struct {}

// Add adds an entity to the list.
func (l *AbstractList) Add(e Entity) {
  // ...
}

// Remove removes an entity from the list.
func (l *AbstractList) Remove(e Entity) {
  // ...
}
```

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// ConcreteList is a list of entities.
type ConcreteList struct {
  *AbstractList
}
```

</td><td>

```go
// ConcreteList is a list of entities.
type ConcreteList struct {
  list *AbstractList
}

// Add adds an entity to the list.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove removes an entity from the list.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Go รองรับ [type embedding](https://go.dev/doc/effective_go#embedding) ซึ่งเป็น กลไกที่อยู่ระหว่าง inheritance และ composition

เมื่อคุณ embed type หนึ่งเข้าไปใน struct อื่น
struct ด้านนอกจะได้รับ method ของ type ที่ฝังอยู่โดยอัตโนมัติ
โดย method เหล่านั้นจะทำหน้าที่ delegate (เรียกต่อ) ไปยัง method เดียวกันของค่าที่ฝังไว้

struct ยังจะได้รับ field ที่มีชื่อเหมือนกับ type ที่ถูกฝัง
ดังนั้น ถ้า type ที่ embed เป็นแบบ public → field นั้นก็จะกลายเป็น public ด้วยโดยอัตโนมัติ

และเพื่อให้ struct คงความเข้ากันได้กับเวอร์ชันเก่า (backward compatibility)
ทุกเวอร์ชันในอนาคต จำเป็นต้องคง type ที่ฝังไว้ มิฉะนั้นจะทำให้ code ที่พึ่งพา method จากการ embed พังได้

การ embed type โดยตรงมักไม่จำเป็นนัก
มันเป็นเพียง “ความสะดวก” ที่ช่วยให้คุณไม่ต้องเขียน method delegate ด้วยตัวเอง

แม้คุณจะ embed เป็น *interface* (เช่น AbstractList) แทนที่จะเป็น struct
สิ่งนี้ก็ยังช่วยให้คุณ ยืดหยุ่นต่อการเปลี่ยนแปลงในอนาคตได้มากขึ้น
แต่ถึงอย่างนั้น ก็ยัง เปิดเผยรายละเอียดภายใน ว่า concrete list ที่คุณใช้นั้น
มีการอิงอยู่กับ abstract implementation อยู่เบื้องหลังอยู่ดี

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// AbstractList is a generalized implementation
// for various kinds of lists of entities.
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}

// ConcreteList is a list of entities.
type ConcreteList struct {
  AbstractList
}
```

</td><td>

```go
// ConcreteList is a list of entities.
type ConcreteList struct {
  list AbstractList
}

// Add adds an entity to the list.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove removes an entity from the list.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

ไม่ว่าจะเป็นการ embed struct หรือ embed interface — การฝัง type แบบนี้ จะจำกัดความสามารถในการพัฒนา (evolve) ของ type ที่ฝังไว้ในอนาคต

ข้อจำกัดที่ตามมา ได้แก่:
* การเพิ่ม method ใน interface ที่ถูกฝัง จะถือว่าเป็น breaking change (ทำให้โค้ดเดิมพัง)
* การลบ method จาก struct ที่ฝังไว้ ก็เป็น breaking change
* การลบ type ที่ถูก embed ออกไป ถือว่าเป็น breaking change
* แม้แต่การ เปลี่ยนไปใช้ type อื่นที่ implement interface เดียวกันก็ยังถือเป็น breaking change เช่นกัน

ถึงแม้การเขียน method แบบ delegate ด้วยตัวเองจะดูน่าเบื่อ
แต่การลงทุนลงแรงตรงนี้จะให้ประโยชน์ระยะยาว เช่น:
* ซ่อนรายละเอียดของ implementation ภายใน ไม่ให้รั่วออกไป
* เปิดโอกาสให้เปลี่ยนแปลงโครงสร้างภายใน ได้ในอนาคต โดยไม่กระทบผู้ใช้
* ช่วยให้เอกสาร API ชัดเจนขึ้น เพราะทุก method ของ interface จะปรากฏตรง ๆ ไม่ต้องตามไปดูว่า embedded มาจากไหน

### Avoid Using Built-In Names

ตามที่ระบุไว้ใน ภาษา Go [language specification](https://go.dev/ref/spec) — มี ชื่อที่ถูกประกาศไว้ล่วงหน้า ([predeclared identifiers](https://go.dev/ref/spec#Predeclared_identifiers))
ที่ไม่ควรนำมาใช้เป็นชื่อในโปรแกรมของเราเอง เช่น int, string, error, len, bool, copy, make ฯลฯ

หากคุณใช้ชื่อเหล่านี้ซ้ำในบริบทของคุณเอง อาจทำให้:
* ค่าต้นฉบับถูก shadow ใน scope ปัจจุบันหรือลูก ๆ
* โค้ดอ่านยาก สับสน และยากต่อการ debug หรือค้นหา
* บางกรณี compiler จะเตือน แต่บางกรณีจะทำงานได้ และอาจแอบแฝง bug ที่ตรวจเจอยาก

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var error string
// `error` กลายเป็นตัวแปร string → ทำให้ shadow type error เดิมของ Go

// หรือ

func handleErrorMessage(error string) {
    // ชื่อพารามิเตอร์ `error` shadow type `error` ที่เป็น built-in
}
```

</td><td>

```go
var errorMessage string
// `error` ยังคงอ้างถึง type error ของภาษาได้ตามปกติ

// หรือ

func handleErrorMessage(msg string) {
    // ชื่อพารามิเตอร์ `msg` ไม่ทับกับชื่อ built-in ใด ๆ
}
```

</td></tr>
<tr><td>

```go
type Foo struct {
    // While these fields technically don't
    // constitute shadowing, grepping for
    // `error` or `string` strings is now
    // ambiguous.
    error  error
    string string
}

func (f Foo) Error() error {
    // `error` and `f.error` are
    // visually similar
    return f.error
}

func (f Foo) String() string {
    // `string` and `f.string` are
    // visually similar
    return f.string
}
```

</td><td>

```go
type Foo struct {
    // `error` and `string` strings are
    // now unambiguous.
    err error
    str string
}

func (f Foo) Error() error {
    return f.err
}

func (f Foo) String() string {
    return f.str
}
```

</td></tr>
</tbody></table>

โปรดทราบว่า compiler ของ Go จะไม่แสดง error หากคุณใช้ชื่อที่ชนกับ predeclared identifiers (ชื่อที่ถูกประกาศไว้ล่วงหน้า เช่น error, string, int, len, ฯลฯ)

อย่างไรก็ตาม เครื่องมือวิเคราะห์โค้ด เช่น `go vet`
จะสามารถตรวจจับกรณีเหล่านี้ (รวมถึงการ shadow อื่น ๆ) ได้อย่างถูกต้อง และช่วยเตือนให้คุณระวัง

### Avoid `init()`

ควรหลีกเลี่ยงการใช้ฟังก์ชัน `init()` ใน Go ให้มากที่สุดเท่าที่เป็นไปได้
แต่ถ้าจำเป็นจริง ๆ หรือมีเหตุผลที่เหมาะสมในการใช้ `init()` โค้ดภายในควรพยายามปฏิบัติตามแนวทางดังนี้

1. ต้องทำงานแบบกำหนดผลลัพธ์ได้แน่นอน
   ไม่ควรให้ผลลัพธ์ของ `init()` เปลี่ยนแปลงตามสภาพแวดล้อมหรือวิธีเรียกโปรแกรม
2. อย่าพึ่งพาลำดับหรือผลข้างเคียงของ `init()` อื่น ๆ
   ถึงแม้ Go จะมีลำดับการเรียก `init()` ที่แน่นอน แต่ code สามารถเปลี่ยนได้ในอนาคต
   การพึ่งพา `init()` ของไฟล์อื่นหรือ package อื่นจะทำให้ระบบเปราะบาง และเกิด bug ได้ง่าย
3. หลีกเลี่ยงการเข้าถึงหรือแก้ไข state ของระบบหรือ environment
   เช่น: ข้อมูลของเครื่อง, environment variables, working directory, ค่าพารามิเตอร์ของโปรแกรม ฯลฯ
4. หลีกเลี่ยงการทำ I/O ทุกประเภท เช่นการอ่านเขียนไฟล์, เชื่อมต่อ network, หรือเรียก system call


หาก code ไม่สามารถทำตามข้อกำหนดข้างต้นได้
แสดงว่า code เหล่านั้น ควรถูกย้ายออกจาก `init()` และเขียนเป็นฟังก์ชันช่วยเหลือ (helper)
ให้ถูกเรียกอย่างชัดเจนจาก `main()` หรือจุดอื่นที่เหมาะสมใน lifecycle ของโปรแกรม

โดยเฉพาะอย่างยิ่งใน library ที่เขียนให้คนอื่นใช้งาน
ควร หลีกเลี่ยงการทำงานอัตโนมัติใน `init()` อย่างเด็ดขาด — เพื่อให้ predictable และควบคุมได้ง่าย

สรุป:

`init()` อาจดูสะดวก แต่หากใช้ผิดที่ผิดเวลา จะสร้างความซับซ้อนและทำให้โค้ดพังยาก
ทางที่ดีคือควบคุมการเริ่มต้นทุกอย่างผ่าน `main()` หรือ explicit call แทนการพึ่ง “init magic”

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Foo struct {
    // ...
}

var _defaultFoo Foo

func init() {
    _defaultFoo = Foo{
        // ...
    }
}
```

</td><td>

```go
var _defaultFoo = Foo{
    // ...
}

// or, better, for testability:

var _defaultFoo = defaultFoo()

func defaultFoo() Foo {
    return Foo{
        // ...
    }
}
```

</td></tr>
<tr><td>

```go
type Config struct {
    // ...
}

var _config Config

func init() {
    // Bad: based on current directory
    cwd, _ := os.Getwd()

    // Bad: I/O
    raw, _ := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )

    yaml.Unmarshal(raw, &_config)
}
```

</td><td>

```go
type Config struct {
    // ...
}

func loadConfig() Config {
    cwd, err := os.Getwd()
    // handle err

    raw, err := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )
    // handle err

    var config Config
    yaml.Unmarshal(raw, &config)

    return config
}
```

</td></tr>
</tbody></table>

จากแนวทางที่กล่าวมาข้างต้น ยังมีบางกรณีที่ การใช้ `init()` อาจเหมาะสมหรือจำเป็น เช่น:

- นิพจน์ (expression) ที่ซับซ้อน: ซึ่งไม่สามารถกำหนดค่าได้ด้วย assignment เดียว เช่น การสร้าง map ซ้อนหลายชั้น หรือค่าคงที่ที่ต้องคำนวณหลายขั้นตอน
- ระบบที่ต้องการ hook แบบ plug-in: เช่น การ register dialect ของ `database/sql`, register `encoder/decoder` หรือ handler กับ registry แบบ global
- การ optimize สำหรับระบบอย่าง [Google Cloud Functions](https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations) ที่เน้นให้ initializations เกิดเพียงครั้งเดียว และ reuse object เดิมใน future invocations ได้ — โดยที่ init() จะทำงานแค่รอบแรกเท่านั้น จึงเหมาะกับ deterministic precomputation

### Exit in Main

ในโปรแกรมภาษา Go หากต้องการออกจากโปรแกรมทันที ควรใช้ [`os.Exit`](https://pkg.go.dev/os#Exit) หรือ [`log.Fatal*`](https://pkg.go.dev/log#Fatal)
อย่าใช้ panic เพื่อออกจากโปรแกรม — อ่านเพิ่มเติมได้ที่หัวข้อ [don't panic](#dont-panic)

ให้เรียก `os.Exit` หรือ `log.Fatal*` **เฉพาะในฟังก์ชัน `main()`** เท่านั้น
ฟังก์ชันอื่น ๆ ควร คืนค่า error กลับมาให้ caller จัดการเอง

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func main() {
  body := readFile(path)
  fmt.Println(body)
}

func readFile(path string) string {
  f, err := os.Open(path)
  if err != nil {
    log.Fatal(err)
  }

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  return string(b)
}
```

</td><td>

```go
func main() {
  body, err := readFile(path)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(body)
}

func readFile(path string) (string, error) {
  f, err := os.Open(path)
  if err != nil {
    return "", err
  }

  b, err := io.ReadAll(f)
  if err != nil {
    return "", err
  }

  return string(b), nil
}
```

</td></tr>
</tbody></table>

เหตุผล: ทำไมจึงควรเรียก `os.Exit` หรือ `log.Fatal*` แค่ใน main()

- ควบคุม flow ได้ยาก: เมื่อต้องวิเคราะห์ลำดับการทำงานของโปรแกรม จะทำได้ยากมาก เพราะทุกฟังก์ชันมีสิทธิ์เรียก exit ได้
  ทำให้ไม่สามารถมั่นใจได้ว่าโค้ดหลังจากนั้นจะถูกเรียกหรือไม่
- เขียน test ได้ลำบาก: ถ้าฟังก์ชันทดลองเรียก `log.Fatal()` หรือ `os.Exit()` จะทำให้ test ที่เรียกมันอยู่หยุดทำงานทันที
  ส่งผลให้ test อื่นที่ยังไม่ได้รัน ถูกข้ามไปทั้งหมด ซึ่งอาจทำให้พลาดเจอ bug ที่สำคัญได้
- ข้ามขั้นตอน cleanup ที่ใช้ defer: การออกจากโปรแกรมโดยตรงจะ ข้ามฟังก์ชันที่ถูก `defer` ไว้
  นั่นหมายถึง การล้างไฟล์, ปล่อย resource, ปิด connection ฯลฯ จะไม่ถูกเรียก
  และอาจทำให้เกิด memory leak หรือปัญหาทับซ้อนภายหลัง

#### Exit Once

หากเป็นไปได้ ควรเรียก `os.Exit` หรือ `log.Fatal` **ไม่เกินหนึ่งครั้ง** ภายในฟังก์ชัน `main()`
ในกรณีที่มีหลายเงื่อนไขที่อาจทำให้โปรแกรมหยุดทำงาน ควรแยก logic เหล่านั้นออกมาไว้ในฟังก์ชันแยก และให้ return error กลับมา

ข้อดีของแนวทางนี้
* ทำให้ main() สั้น กระชับ อ่านง่าย
* ธุรกิจหลัก (key business logic) ถูกแยกออกมาเป็นฟังก์ชันที่ ทดสอบได้ง่าย
* ช่วยจัดการ error ได้ชัดเจนและปลอดภัยยิ่งขึ้น

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
package main

func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

  // If we call log.Fatal after this line,
  // f.Close will not be called.

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  // ...
}
```

</td><td>

```go
package main

func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}

func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()

  b, err := io.ReadAll(f)
  if err != nil {
    return err
  }

  // ...
}
```

</td></tr>
</tbody></table>

ตัวอย่างด้านบนใช้ `log.Fatal` แต่อันที่จริง แนวทางนี้สามารถใช้ได้กับ `os.Exit` หรือโค้ดจากไลบรารีใด ๆ ก็ตามที่เรียก `os.Exit` เช่นกัน

```go
func main() {
  if err := run(); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

คุณสามารถปรับรูปแบบของฟังก์ชัน `run()` ให้เหมาะสมกับความต้องการของโปรแกรมได้

ตัวอย่างเช่น หากโปรแกรมของคุณจำเป็นต้อง ออกจากระบบด้วย exit code ที่เฉพาะเจาะจงในแต่ละกรณีของความล้มเหลว
คุณสามารถเขียนให้ `run()` คืนค่าเป็น int แทน error ได้โดยตรง เพื่อระบุ exit code นั้น

นอกจากนี้ แนวทางนี้ยังช่วยให้คุณสามารถ เขียน unit test เพื่อตรวจสอบพฤติกรรมของ `run()` ได้โดยตรง โดยไม่ต้องพึ่ง `os.Exit()` จริง

```go
func main() {
  os.Exit(run(args))
}

func run() (exitCode int) {
  // ...
}
```

โดยทั่วไปแล้ว ตัวอย่างที่ใช้ฟังก์ชัน `run()` นั้น ไม่ใช่กฎตายตัว
คุณสามารถปรับเปลี่ยนชื่อรูปแบบหรือโครงสร้างของ `run()` ได้อย่างยืดหยุ่นตามความเหมาะสม

- รับอาร์กิวเมนต์จากบรรทัดคำสั่งโดยตรง เช่น `run(os.Args[1:])`
- ให้ `main()` ทำหน้าที่ parse อาร์กิวเมนต์ แล้วส่งต่อไปยัง `run`
- ใช้ custom error type เพื่อ แนบ exit code กลับไปยัง `main()`
- แยก business logic ออกไปอยู่อีกเลเยอร์หนึ่งที่ไม่ใช่ package main

**แนวคิดหลักที่แนะนำ**

ให้มีเพียงจุดเดียวใน `main()` ที่มีหน้าที่ “exit โปรแกรม” เท่านั้น
ไม่ว่าจะเป็น `os.Exit()`, `log.Fatal()` หรืออย่างอื่น
ส่วน logic อื่น ๆ ให้ return กลับมาให้ `main()` ตัดสินใจว่าโปรแกรมจะหยุดหรือไม่

### Use field tags in marshaled structs

ถ้าคุณมี struct ที่จะนำไปแปลง (marshal) เป็น JSON, YAML หรือฟอร์แมตอื่น ๆ ที่รองรับการใช้ tag กำหนดชื่อ field
ควรกำหนด tag ให้ชัดเจนสำหรับแต่ละ field เพื่อความชัดเจนและปลอดภัยในการเปลี่ยนชื่อในอนาคต

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Stock struct {
  Price int
  Name  string
}

bytes, err := json.Marshal(Stock{
  Price: 137,
  Name:  "UBER",
})
```

</td><td>

```go
type Stock struct {
  Price int    `json:"price"`
  Name  string `json:"name"`
  // Safe to rename Name to Symbol.
}

bytes, err := json.Marshal(Stock{
  Price: 137,
  Name:  "UBER",
})
```

</td></tr>
</tbody></table>

เหตุผล:

รูปแบบข้อมูลที่ถูก serialize (เช่น JSON, YAML) จาก struct
ถือเป็น “ข้อกำหนด” ระหว่างระบบต่าง ๆ
ไม่ว่าจะเป็นระบบ frontend, backend, API, หรือ third-party service

หากมีการเปลี่ยนแปลงรูปแบบของข้อมูลที่ serialize เช่น การเปลี่ยนชื่อ field
จะทำให้ข้อกำหนดนี้พัง ซึ่งอาจส่งผลให้ระบบอื่นที่ใช้งานข้อมูลนี้ ทำงานผิดพลาด ได้ทันที

การกำหนดชื่อ field ที่ใช้ในการ serialize ผ่าน tag (เช่น json:"name") จะช่วย:
* ทำให้ ข้อกำหนดนั้นชัดเจน
* ป้องกันการเปลี่ยนแปลงโดยไม่ตั้งใจ เช่น การ refactor หรือ rename field
* ทำให้โค้ดมีความ มั่นคงและปลอดภัยมากขึ้น เมื่อต้องแก้ไขหรือขยายระบบในอนาคต

### Don't fire-and-forget goroutines

แม้ว่า Goroutine จะเบาและประหยัดทรัพยากรกว่า thread แต่ก็ ไม่ได้ฟรี
เพราะทุก Goroutine ต้องใช้หน่วยความจำสำหรับ stack และ CPU สำหรับ scheduling

ในหลายกรณี ค่าใช้จ่ายเหล่านี้อาจน้อยมาก
แต่ถ้า สร้างจำนวนมากโดยไม่มีการจัดการอายุการใช้งาน จะทำให้เกิดปัญหาหนักตามมา เช่น:
* ปัญหา performance จากการใช้ CPU และหน่วยความจำมากเกินไป
* หน่วงการเก็บขยะ (GC) เพราะมี Goroutine อ้างอิงถึง object ที่ไม่จำเป็นแล้ว
* Resource รั่ว เช่น socket, file, memory ที่ไม่ถูกปล่อย

ข้อแนะนำ
* อย่าปล่อยให้ Goroutine รั่วใน production code
* ใช้ [go.uber.org/goleak](https://pkg.go.dev/go.uber.org/goleak) เพื่อตรวจจับ Goroutine รั่วในการทดสอบ
* Goroutine ทุกตัวควรมี เวลาในการจบการทำงานที่คาดเดาได้ หรือ ช่องทางให้สามารถสั่งหยุดได้ (เช่น context, channel)
และในทุกกรณีควรมีวิธี รอให้ Goroutine ทำงานเสร็จ เช่น sync.WaitGroup หรือ <-doneChan

ตัวอย่าง:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
go func() {
  for {
    flush()
    time.Sleep(delay)
  }
}()
```

</td><td>

```go
var (
  stop = make(chan struct{}) // channel สำหรับสั่งให้ goroutine หยุดทำงาน
  done = make(chan struct{}) // channel สำหรับบอกว่า goroutine หยุดแล้ว
)
go func() {
  defer close(done) // ปิด channel เมื่อ goroutine จบ

  ticker := time.NewTicker(delay)
  defer ticker.Stop()
  for {
    select {
    case <-ticker.C:
      flush()
    case <-stop:
      return
    }
  }
}()

// ในที่อื่นของโปรแกรม...
close(stop)  // สั่งหยุด goroutine
<-done       // รอให้ goroutine หยุดก่อนดำเนินการต่อ
```

</td></tr>
<tr><td>

Goroutine นี้ไม่มีทางหยุดได้เลย
มันจะทำงานไปเรื่อย ๆ จนกว่าแอปพลิเคชันจะปิดตัวลงเท่านั้น

</td><td>

Goroutine นี้สามารถหยุดได้โดยเรียก `close(stop)`
และเราสามารถรอให้มันหยุดอย่างสมบูรณ์ได้ด้วย `<-done`

</td></tr>
</tbody></table>

#### Wait for goroutines to exit

ถ้ามีการสร้าง goroutine ขึ้นมาในระบบ เราควรมีวิธีที่จะรอให้มันหยุดทำงานอย่างเหมาะสม เพื่อป้องกัน resource leak และให้โปรแกรมปิดตัวได้อย่างเป็นระเบียบ

- ใช้ `sync.WaitGroup` เหมาะเมื่อเราต้องรอให้ หลาย goroutine ทำงานเสร็จทั้งหมด

  ```go
  var wg sync.WaitGroup
  for i := 0; i < N; i++ {
    wg.Add(1) // เพิ่มจำนวน goroutine ที่เราจะรอ
    go func() {
      defer wg.Done() // บอกว่า goroutine นี้เสร็จแล้ว
      // ...
    }()
  }

  // รอจนกว่าทุก goroutine จะเสร็จ
  wg.Wait()
  ```

- ถ้ามีแค่ goroutine เดียว ที่เราต้องรอสามารถใช้ channel เปล่า (`chan struct{}`) เพื่อสื่อสารว่ามันทำงานเสร็จแล้ว

  ```go
  done := make(chan struct{})
  go func() {
    defer close(done) // ปิด channel เพื่อส่งสัญญาณว่า goroutine เสร็จแล้ว
    // ...
  }()

  // รอให้ goroutine ทำงานเสร็จ
  <-done
  ```

#### No goroutines in `init()`

ฟังก์ชัน `init()` ไม่ควรสร้าง goroutine (ดูเพิ่มเติมที่หัวข้อ [Avoid init()](#avoid-init))

หาก package จำเป็นต้องมี background goroutine
ควร expose object ที่รับผิดชอบในการจัดการ lifetime ของ goroutine นั้นโดยเฉพาะ
object นี้ต้องมีเมธอด เช่น `Close`, `Stop` หรือ `Shutdown`
เพื่อให้สามารถ ส่งสัญญาณให้ goroutine หยุดทำงาน และ รอจน goroutine หยุดจริง ก่อนจะคืนค่ากลับมา

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func init() {
  go doWork()
}

func doWork() {
  for {
    // ...
  }
}
```

</td><td>

```go
type Worker struct{ /* ... */ }

func NewWorker(...) *Worker {
  w := &Worker{
    stop: make(chan struct{}),
    done: make(chan struct{}),
    // ...
  }
  go w.doWork()
}

func (w *Worker) doWork() {
  defer close(w.done)
  for {
    // ...
    case <-w.stop:
      return
  }
}

// Shutdown ใช้สำหรับสั่งให้ worker หยุดทำงาน
// และรอจนแน่ใจว่า worker หยุดแล้วจริง ๆ
func (w *Worker) Shutdown() {
  close(w.stop)
  <-w.done
}
```

</td></tr>
<tr><td>

โค้ดนี้จะ สร้าง goroutine ทำงานเบื้องหลังแบบไม่มีเงื่อนไข ทันทีที่ผู้ใช้ import package นี้
ผู้ใช้ไม่สามารถควบคุมการทำงานของ goroutine ได้เลย และก็ไม่มีทางหยุดมันด้วย

</td><td>

โค้ดนี้จะ สร้าง worker ก็ต่อเมื่อผู้ใช้เรียกใช้งานโดยตรง
และยังมีช่องทางให้หยุดการทำงานของ worker อย่างปลอดภัย
ทำให้ผู้ใช้สามารถคืน resource ที่ใช้โดย worker ได้อย่างเหมาะสม

หมายเหตุ: ถ้า worker ตัวเดียวจัดการหลาย goroutine ควรใช้ sync.WaitGroup เพื่อรอให้ทุก goroutine หยุดก่อนจริง ๆ
ดูหัวข้อ [Wait for goroutines to exit](#wait-for-goroutines-to-exit) ประกอบด้วยครับ

</td></tr>
</tbody></table>

## Performance

แนวทางในหัวข้อนี้เน้นเฉพาะ ส่วนที่มีการใช้งานหนักเท่านั้น

### Prefer strconv over fmt

เมื่อคุณต้องการแปลงค่าประเภทพื้นฐาน (primitive) เป็น string หรือแปลงกลับ
ควรใช้แพ็กเกจ `strconv` เพราะ ทำงานเร็วกว่า `fmt`

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for i := 0; i < b.N; i++ {
  s := fmt.Sprint(rand.Int())
}
```

</td><td>

```go
for i := 0; i < b.N; i++ {
  s := strconv.Itoa(rand.Int())
}
```

</td></tr>
<tr><td>

```plain
BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
```

</td><td>

```plain
BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
```

</td></tr>
</tbody></table>

### Avoid repeated string-to-byte conversions

อย่าสร้าง slice ของ byte ([]byte) จาก string ค่าคงที่แบบซ้ำ ๆ ในหลาย ๆ จุดของโค้ด
ให้แปลงเพียงครั้งเดียว แล้วเก็บค่าไว้ใช้งานภายหลัง

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for i := 0; i < b.N; i++ {
  w.Write([]byte("Hello world"))
}
```

</td><td>

```go
data := []byte("Hello world")
for i := 0; i < b.N; i++ {
  w.Write(data)
}
```

</td></tr>
<tr><td>

```plain
BenchmarkBad-4   50000000   22.2 ns/op
```

</td><td>

```plain
BenchmarkGood-4  500000000   3.25 ns/op
```

</td></tr>
</tbody></table>

### Prefer Specifying Container Capacity

ควรกำหนดความจุของ container (เช่น slice หรือ map) ให้ชัดเจนเมื่อเป็นไปได้
เพื่อให้ระบบสามารถจัดสรรหน่วยความจำล่วงหน้า ลดการจัดสรรเพิ่มเติมในอนาคต
(ซึ่งจะเกิดการ copy และขยาย container เมื่อมีการเพิ่มข้อมูล)

#### Specifying Map Capacity Hints

เมื่อเป็นไปได้ ควรระบุขนาดโดยประมาณ ตอนที่สร้าง `map` ด้วย `make()`

```go
make(map[T1]T2, hint)
```

การระบุขนาดนี้ช่วยให้ Go สามารถจัดสรร bucket ของ hashmap ได้ใกล้เคียงกับขนาดที่ต้องการตั้งแต่เริ่มต้น
ซึ่งจะช่วยลดความจำเป็นในการขยาย map และลดจำนวนครั้งที่ต้องจัดสรรหน่วยความจำเพิ่มเติมเมื่อมีการเพิ่มข้อมูลเข้าไป

อย่างไรก็ตาม ต่างจาก slice, การระบุขนาดของ `map` ไม่รับประกัน ว่าจะมีการจัดสรรหน่วยความจำทั้งหมดล่วงหน้า
แต่มันเป็นเพียงการ “ประมาณ” จำนวน bucket ที่ต้องใช้ ดังนั้นการเพิ่มข้อมูลเข้าไปใน map
ยังคงอาจทำให้เกิดการจัดสรรเพิ่มเติมได้ แม้จะยังไม่เกินขนาดที่ระบุไว้ก็ตาม

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
m := make(map[string]os.FileInfo)

files, _ := os.ReadDir("./files")
for _, f := range files {
    m[f.Name()] = f
}
```

</td><td>

```go

files, _ := os.ReadDir("./files")

m := make(map[string]os.DirEntry, len(files))
for _, f := range files {
    m[f.Name()] = f
}
```

</td></tr>
<tr><td>

สร้าง `m` โดยไม่ระบุขนาดเริ่มต้น อาจทำให้เกิดการจัดสรรหน่วยความจำเพิ่มเติมบ่อยครั้งในระหว่างการใส่ข้อมูล

</td><td>

สร้าง `m` โดยระบุขนาดเริ่มต้น ช่วยลดจำนวนครั้งที่ต้องจัดสรรหน่วยความจำในระหว่างการใส่ข้อมูลลงใน `map` ได้

</td></tr>
</tbody></table>

#### Specifying Slice Capacity

ในกรณีที่สามารถคาดการณ์จำนวนของข้อมูลล่วงหน้าได้ ควรระบุ capacity ไว้ตอนสร้าง slice ด้วย `make()` โดยเฉพาะในกรณีที่มีการใช้ append() บ่อย ๆ

```go
make([]T, length, capacity)
```

ต่างจาก map ตรงที่ capacity ของ slice ไม่ใช่แค่คำใบ้: ตัวคอมไพเลอร์จะจัดสรรหน่วยความจำตามความจุที่ระบุไว้ทันที ซึ่งหมายความว่า การ `append()` จะไม่ต้องจัดสรรหน่วยความจำเพิ่มเติมเลย (ตราบใดที่ความยาวของ slice ยังไม่เกินความจุที่กำหนดไว้) แต่เมื่อเกินแล้ว ระบบจะต้องจัดสรรใหม่เพื่อรองรับข้อมูลที่เพิ่มเข้ามาอีก.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td></tr>
<tr><td>

```plain
BenchmarkBad-4    100000000    2.48s
```

</td><td>

```plain
BenchmarkGood-4   100000000    0.21s
```

</td></tr>
</tbody></table>

## Style

### Avoid overly long lines

พยายามอย่าเขียนโค้ดในบรรทัดเดียวจนยาวเกินไป จนผู้อ่านต้องเลื่อนจอแนวนอน หรือเอียงศีรษะเพื่ออ่าน

แนะนำให้จำกัดความยาวของบรรทัดแบบ soft limit ไว้ที่ **99 ตัวอักษร** — หมายความว่าควรพยายามห่อบรรทัดก่อนถึงจุดนี้ แต่ไม่ใช่ข้อบังคับตายตัว ถ้ามีเหตุผลเหมาะสมก็สามารถเขียนเกินได้.

### Be Consistent

แนวทางต่าง ๆ ที่ระบุไว้ในเอกสารนี้ บางข้อสามารถประเมินได้อย่างชัดเจน แต่บางข้อก็ขึ้นอยู่กับสถานการณ์ บริบท หรือดุลยพินิจ

เหนือสิ่งอื่นใด **ควรรักษาความสม่ำเสมอ**

โค้ดที่มีรูปแบบสม่ำเสมอจะดูแลรักษาได้ง่ายกว่า เข้าใจได้ง่ายกว่า ใช้พลังสมองน้อยกว่า และง่ายต่อการปรับปรุงหรือย้ายไปใช้แนวทางใหม่เมื่อมาตรฐานเปลี่ยนแปลง หรือเมื่อต้องแก้ปัญหาที่คล้ายกันในวงกว้าง

ในทางกลับกัน หากใน codebase เดียวกันมีหลายรูปแบบปะปนหรือขัดแย้งกัน จะทำให้เกิดภาระในการดูแล รู้สึกลังเล และเกิดความสับสน ซึ่งทั้งหมดนี้ส่งผลต่อความเร็วในการพัฒนา ความยากลำบากในการรีวิวโค้ด และการเกิดบั๊กโดยตรง

เมื่อจะนำแนวทางเหล่านี้ไปปรับใช้ใน codebase แนะนำให้ทำในระดับแพ็กเกจ (package) หรือมากกว่านั้น เพราะถ้าทำแค่ระดับย่อยกว่านั้น (sub-package) จะย้อนแย้งกับหลักการข้างต้น และยิ่งทำให้มีหลายรูปแบบในระบบเดียวกัน

### Group Similar Declarations

Go รองรับการจัดกลุ่มคำประกาศประเภทเดียวกันให้ดูเรียบร้อยและอ่านง่ายขึ้น

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import "a"
import "b"
```

</td><td>

```go
import (
  "a"
  "b"
)
```

</td></tr>
</tbody></table>

ข้อนี้ใช้ได้กับการประกาศ constants, variables, และ type ด้วยเช่นกัน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go

const a = 1
const b = 2



var a = 1
var b = 2



type Area float64
type Volume float64
```

</td><td>

```go
const (
  a = 1
  b = 2
)

var (
  a = 1
  b = 2
)

type (
  Area float64
  Volume float64
)
```

</td></tr>
</tbody></table>

ควรจัดกลุ่มเฉพาะการประกาศที่เกี่ยวข้องกันเท่านั้น อย่าจัดกลุ่มการประกาศที่ไม่เกี่ยวข้องกัน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
  EnvVar = "MY_ENV"
)
```

</td><td>

```go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

const EnvVar = "MY_ENV"
```

</td></tr>
</tbody></table>

Groups are not limited in where they can be used. For example, you can use them
inside of functions.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func f() string {
  red := color.New(0xff0000)
  green := color.New(0x00ff00)
  blue := color.New(0x0000ff)

  // ...
}
```

</td><td>

```go
func f() string {
  var (
    red   = color.New(0xff0000)
    green = color.New(0x00ff00)
    blue  = color.New(0x0000ff)
  )

  // ...
}
```

</td></tr>
</tbody></table>

แม้ว่าหลักการทั่วไปจะให้จัดกลุ่มเฉพาะตัวแปรที่เกี่ยวข้องกัน แต่ ในกรณีที่ตัวแปรหลายตัวถูกประกาศอยู่ติดกันในฟังก์ชัน (แม้จะไม่เกี่ยวข้องกันโดยตรง) ก็ควรจัดกลุ่มไว้ด้วยกันเพื่อความเป็นระเบียบและอ่านง่าย

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func (c *client) request() {
  caller := c.name
  format := "json"
  timeout := 5*time.Second
  var err error

  // ...
}
```

</td><td>

```go
func (c *client) request() {
  var (
    caller  = c.name
    format  = "json"
    timeout = 5*time.Second
    err error
  )

  // ...
}
```

</td></tr>
</tbody></table>

### Import Group Ordering

ควรมี สองกลุ่ม สำหรับ import

- Standard library – เช่น "fmt", "net/http", "time" ฯลฯ
- ทุกอย่างอื่น – ได้แก่ third-party libraries ("go.uber.org/zap", "github.com/pkg/errors") หรือ internal packages ของโปรเจกต์เอง

การจัดกลุ่มแบบนี้เป็น ค่าเริ่มต้นที่ goimports ใช้ และช่วยให้โค้ดอ่านง่ายและมีมาตรฐานเดียวกัน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import (
  "fmt"
  "os"
  "go.uber.org/atomic"
  "golang.org/x/sync/errgroup"
)
```

</td><td>

```go
import (
  "fmt"
  "os"

  "go.uber.org/atomic"
  "golang.org/x/sync/errgroup"
)
```

</td></tr>
</tbody></table>

### Package Names

เมื่อตั้งชื่อ package ควรยึดตามแนวทางดังนี้:

- ช้ตัวพิมพ์เล็กทั้งหมด – หลีกเลี่ยงการใช้ตัวพิมพ์ใหญ่หรือ _ (underscore)
- ไม่ควรต้องมีการเปลี่ยนชื่อเมื่อ import – ควรสามารถใช้ชื่อ package ได้ตรง ๆ โดยไม่ต้องทำ named import
- สั้นและชัดเจน – เพราะชื่อ package จะถูกใช้ซ้ำในทุกจุดที่เรียกใช้ เช่น log.Info()
- อย่าใช้พหูพจน์ – เช่น ใช้ net/url แทน net/urls
- หลีกเลี่ยงชื่อทั่วไปที่ไม่สื่อความหมาย – เช่น common, util, shared, หรือ lib เพราะไม่บอกว่าภายในทำอะไร

ดูเพิ่มเติม [Package Names](https://go.dev/blog/package-names) and [Style guideline for Go packages](https://rakyll.org/style-packages/).

### Function Names

Go แนะนำให้ใช้ รูปแบบตัวพิมพ์ผสม ([MixedCaps for function
names](https://go.dev/doc/effective_go#mixed-caps)) เช่น DoSomething, handleRequest
ยกเว้นกรณีพิเศษสำหรับฟังก์ชันทดสอบ (test functions) ที่สามารถใช้ _ เพื่อแยกกลุ่มเคสที่เกี่ยวข้องกันได้ เช่น: `TestMyFunction_WhatIsBeingTested`

### Import Aliasing

ควรใช้ alias ก็ต่อเมื่อชื่อ package ไม่ตรงกับชื่อท้ายของ path:

```go
import (
  "net/http"

  client "example.com/client-go" // ชื่อจริงของ package อาจไม่ใช่ "client"
  trace "example.com/trace/v2" // ใช้ alias เพื่อชัดเจน
)
```

ในกรณีอื่น ๆ ทั้งหมด ไม่ควรใช้ alias ตอน import
เว้นแต่ว่าจะเกิด ชื่อซ้ำกันโดยตรงระหว่างหลาย package

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import (
  "fmt"
  "os"
  runtimetrace "runtime/trace"

  nettrace "golang.net/x/trace"
)
```

</td><td>

```go
import (
  "fmt"
  "os"
  "runtime/trace"

  nettrace "golang.net/x/trace"
)
```

</td></tr>
</tbody></table>

### Function Grouping and Ordering

- ควรจัดลำดับฟังก์ชันให้สอดคล้องกับ ลำดับการเรียกใช้งานโดยคร่าว ๆ
- ควรจัดกลุ่มฟังก์ชันตาม receiver (เช่น func (s *Server) Serve() ควรอยู่รวมกัน)

ดังนั้น:
* ฟังก์ชันที่ exported (เช่น ฟังก์ชันขึ้นต้นด้วยตัวพิมพ์ใหญ่) ควรอยู่ ตอนต้นของไฟล์
* ให้ตามหลังจาก `struct`, `const`, `var` ที่เกี่ยวข้อง
* ฟังก์ชัน `newXYZ()` หรือ `NewXYZ()` ควรอยู่หลัง type ที่เกี่ยวข้อง และ ก่อน methods อื่นของ receiver นั้น
* ฟังก์ชันแบบ utility ที่ไม่มี receiver ควรอยู่ ท้ายไฟล์

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func (s *something) Cost() {
  return calcCost(s.weights)
}

type something struct{ ... }

func calcCost(n []int) int {...}

func (s *something) Stop() {...}

func newSomething() *something {
    return &something{}
}
```

</td><td>

```go
type something struct{ ... }

func newSomething() *something {
    return &something{}
}

func (s *something) Cost() {
  return calcCost(s.weights)
}

func (s *something) Stop() {...}

func calcCost(n []int) int {...}
```

</td></tr>
</tbody></table>

### Reduce Nesting

ควรเขียนโค้ดให้ ลดระดับการซ้อนให้น้อยที่สุด โดยเฉพาะเมื่อมีเงื่อนไขพิเศษหรือการตรวจสอบ error:
* ให้ จัดการกรณีพิเศษ หรือ error ก่อน แล้ว return หรือ continue ทันที
* โค้ดหลักควรอยู่ในระดับที่ไม่ถูกซ้อนหลายชั้น เพื่อให้อ่านง่ายและเข้าใจได้เร็ว

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for _, v := range data {
  if v.F1 == 1 {
    v = process(v)
    if err := v.Call(); err == nil {
      v.Send()
    } else {
      return err
    }
  } else {
    log.Printf("Invalid v: %v", v)
  }
}
```

</td><td>

```go
for _, v := range data {
  if v.F1 != 1 {
    log.Printf("Invalid v: %v", v)
    continue
  }

  v = process(v)
  if err := v.Call(); err != nil {
    return err
  }
  v.Send()
}
```

</td></tr>
</tbody></table>

### Unnecessary Else

ถ้าโค้ดในทั้งสองฝั่งของ if และ else ทำเพียงแค่การกำหนดค่าให้กับตัวแปรเดียวกัน — เราสามารถเขียนให้ง่ายและอ่านสบายขึ้นโดยไม่ต้องใช้ else

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var a int
if b {
  a = 100
} else {
  a = 10
}
```

</td><td>

```go
a := 10
if b {
  a = 100
}
```

</td></tr>
</tbody></table>

### Top-level Variable Declarations

ในการประกาศตัวแปรระดับบนสุดของ package (นอกฟังก์ชัน), ให้ใช้คีย์เวิร์ด `var` ตามรูปแบบมาตรฐาน และ ไม่ต้องระบุชนิดของตัวแปร เว้นแต่ชนิดของค่าที่กำหนดไว้ต่างจากชนิดของตัวแปร

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var _s string = F()

func F() string { return "A" }
```

</td><td>

```go
var _s = F()
// เนื่องจาก F ระบุไว้อยู่แล้วว่า return ค่าเป็น string
// จึงไม่จำเป็นต้องระบุชนิดตัวแปรซ้ำอีก

func F() string { return "A" }
```

</td></tr>
</tbody></table>

ให้ระบุชนิดของตัวแปร ชัดเจนในกรณีที่ชนิดของค่าที่คืนจาก expression ไม่ตรงกับชนิดที่เราต้องการเป๊ะ ๆ

```go
type myError struct{}

func (myError) Error() string { return "error" }

func F() myError { return myError{} }

var _e error = F()
// F คืนค่าเป็น myError (ซึ่ง implement interface error)
// แต่เราต้องการตัวแปรที่เป็นชนิด error
```

### Prefix Unexported Globals with _

ควรเติม prefix `_` นำหน้าชื่อตัวแปร (`var`) หรือค่าคงที่ (`const`) ที่อยู่ระดับ top-level และ ไม่ export (ชื่อขึ้นต้นด้วยตัวพิมพ์เล็ก) เพื่อให้เห็นชัดว่าเป็น symbol ที่อยู่ระดับ global

เหตุผล:
* ตัวแปรหรือค่าคงที่ที่ประกาศระดับ top-level มี package scope
* ถ้าตั้งชื่อทั่วไปเกินไป เช่น version, timeout, config โดยไม่มี `_` นำหน้า จะทำให้ อาจสับสนกับตัวแปรในไฟล์อื่น ที่อยู่ใน package เดียวกัน
* การเติม `_` จะช่วยให้เห็นชัดว่าเป็น global symbol ไม่ใช่ local หรือ temporary

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// foo.go

const (
  defaultPort = 8080
  defaultUser = "user"
)

// bar.go

func Bar() {
  defaultPort := 9090
  ...
  fmt.Println("Default port", defaultPort)

  // We will not see a compile error if the first line of
  // Bar() is deleted.
}
```

</td><td>

```go
// foo.go

const (
  _defaultPort = 8080
  _defaultUser = "user"
)
```

</td></tr>
</tbody></table>

**ข้อยกเว้น**: ค่าตัวแปร error ที่ไม่ export สามารถใช้ prefix err ได้โดยไม่ต้องเติม `_` นำหน้า
ดูรายละเอียดเพิ่มเติมที่หัวข้อ [Error Naming](#error-naming)

### Embedding in Structs

ถ้าจะใช้ embedded types (ประเภทที่ฝังไว้ใน struct) ควรวางไว้ที่ด้านบนสุดของรายการ field ภายใน struct และ ต้องเว้นบรรทัดว่าง คั่นระหว่าง embedded fields กับ fields ปกติ
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Client struct {
  version int
  http.Client
}
```

</td><td>

```go
type Client struct {
  http.Client

  version int
}
```

</td></tr>
</tbody></table>

การฝัง (Embedding) ควรนำมาซึ่งประโยชน์ที่จับต้องได้ เช่น เพิ่มหรือขยายฟังก์ชันการทำงานของ struct อย่างเหมาะสมทางความหมาย และต้องไม่มีผลกระทบด้านลบต่อผู้ใช้งาน (ดูเพิ่มเติมใน [Avoid Embedding Types in Public Structs](#avoid-embedding-types-in-public-structs))

ข้อยกเว้น: ไม่ควร embed `sync.Mutex` แม้ใน struct ที่ไม่ export ดูเพิ่มเติมที่หัวข้อ: [Zero-value Mutexes are Valid](#zero-value-mutexes-are-valid).

ห้ามฝัง Type เพื่อเหตุผลเหล่านี้:

* เพื่อความสะดวก หรือความสวยงาม โดยไม่มีประโยชน์ที่แท้จริง
* ทำให้การสร้างหรือนำ struct มาใช้งานยุ่งยากขึ้น
* ทำให้ zero value ของ struct ภายนอกหมดความหมายหรือใช้การไม่ได้
* ทำให้มีฟังก์ชันหรือ field ที่ไม่เกี่ยวข้องโผล่ขึ้นมาจาก struct ด้านนอกโดยไม่ตั้งใจ
* ทำให้ type ภายในที่ไม่ export ถูกเปิดเผย
* เปลี่ยนพฤติกรรมการคัดลอก (copy semantics) ของ struct ภายนอก
* เปลี่ยน API หรือ semantic ของ type ภายนอก
* ฝัง type ที่ไม่ใช่รูปแบบหลักของ type นั้น (non-canonical form)
* เปิดเผยรายละเอียดของการ implement ภายใน struct
* ทำให้ผู้ใช้สามารถมองเห็นหรือควบคุมสิ่งที่ควรถูกซ่อนไว้ใน type
* เปลี่ยนพฤติกรรมของฟังก์ชันภายในอย่างที่อาจทำให้ผู้ใช้สับสน

พูดง่าย ๆ ก็คือ: ให้ฝัง (embed) อย่างมีสติและตั้งใจจริงเท่านั้น

แนวทางเช็คง่าย ๆ คือ:
ถ้าเราจะเพิ่ม method หรือ field ที่ export ทั้งหมดของ type ด้านในเข้าไปที่ type ด้านนอกโดยตรง — เรายินดีจะทำแบบนั้นทั้งหมดไหม?
* ถ้าคำตอบคือ “บางอันเท่านั้น” หรือ “ไม่เลย” → อย่า embed type นั้น
* แต่ให้ใช้เป็น field แบบปกติแทน เพื่อหลีกเลี่ยงผลกระทบที่ไม่ตั้งใจต่อ API และการใช้งานของ type ด้านนอก.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type A struct {
    // Bad: A.Lock() and A.Unlock() are
    //      now available, provide no
    //      functional benefit, and allow
    //      users to control details about
    //      the internals of A.
    sync.Mutex
}
```

</td><td>

```go
type countingWriteCloser struct {
    // Good: Write() is provided at this
    //       outer layer for a specific
    //       purpose, and delegates work
    //       to the inner type's Write().
    io.WriteCloser

    count int
}

func (w *countingWriteCloser) Write(bs []byte) (int, error) {
    w.count += len(bs)
    return w.WriteCloser.Write(bs)
}
```

</td></tr>
<tr><td>

```go
type Book struct {
    // Bad: pointer changes zero value usefulness
    io.ReadWriter

    // other fields
}

// later

var b Book
b.Read(...)  // panic: nil pointer
b.String()   // panic: nil pointer
b.Write(...) // panic: nil pointer
```

</td><td>

```go
type Book struct {
    // Good: has useful zero value
    bytes.Buffer

    // other fields
}

// later

var b Book
b.Read(...)  // ok
b.String()   // ok
b.Write(...) // ok
```

</td></tr>
<tr><td>

```go
type Client struct {
    sync.Mutex
    sync.WaitGroup
    bytes.Buffer
    url.URL
}
```

</td><td>

```go
type Client struct {
    mtx sync.Mutex
    wg  sync.WaitGroup
    buf bytes.Buffer
    url url.URL
}
```

</td></tr>
</tbody></table>

### Local Variable Declarations

การประกาศตัวแปรแบบย่อด้วย `:=` ควรใช้เมื่อคุณกำหนดค่าให้ตัวแปรอย่างชัดเจน

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var s = "foo"
```

</td><td>

```go
s := "foo"
```

</td></tr>
</tbody></table>

อย่างไรก็ตาม ก็มีบางกรณีที่การใช้ `var` จะช่วยให้โค้ดดูชัดเจนขึ้นกว่าใช้ `:=` โดยเฉพาะในกรณีที่ต้องการสื่อว่าเป็นค่าเริ่มต้น (default value)
ตัวอย่างเช่น [Declaring Empty Slices](https://go.dev/wiki/CodeReviewComments#declaring-empty-slices)

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func f(list []int) {
  filtered := []int{}
  for _, v := range list {
    if v > 10 {
      filtered = append(filtered, v)
    }
  }
}
```

</td><td>

```go
func f(list []int) {
  var filtered []int
  for _, v := range list {
    if v > 10 {
      filtered = append(filtered, v)
    }
  }
}
```

</td></tr>
</tbody></table>

### nil is a valid slice

nil ถือว่าเป็น slice ที่ถูกต้อง และมีความยาวเป็น 0 `(len(s) == 0)`
ดังนั้น คำแนะนำคือ

- ไม่ควร return slice ว่าง `([]T{})` โดยเจตนาควร `return nil` แทน เมื่อไม่มีข้อมูล

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  if x == "" {
    return []int{}
  }
  ```

  </td><td>

  ```go
  if x == "" {
    return nil
  }
  ```

  </td></tr>
  </tbody></table>

- เพื่อเช็กว่า slice ว่างหรือไม่ ให้ใช้ `len(s) == 0` เสมอ อย่าใช้ `s == nil` ในการตรวจสอบความว่างของ slice

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  func isEmpty(s []string) bool {
    return s == nil
  }
  ```

  </td><td>

  ```go
  func isEmpty(s []string) bool {
    return len(s) == 0
  }
  ```

  </td></tr>
  </tbody></table>

- ค่าศูนย์ของ slice (เช่น slice ที่ประกาศด้วย `var`) สามารถใช้งานได้ทันที โดยไม่ต้องใช้ `make()`

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  nums := []int{}
  // หรือ nums := make([]int)

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td><td>

  ```go
  var nums []int

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td></tr>
  </tbody></table>

อย่าลืมว่า ถึงแม้ nil slice จะเป็น slice ที่ถูกต้อง แต่ก็ ไม่เหมือนกับ slice ที่ถูก allocate แล้วแต่มีความยาวเป็น 0 — อันหนึ่งคือ nil ส่วนอีกอันไม่ใช่ nil — ซึ่งทั้งสองแบบอาจถูกจัดการแตกต่างกันในบางสถานการณ์ เช่น การทำ serialization

```go
var a []int        // nil slice
b := []int{}       // empty but non-nil slice

fmt.Println(a == nil) // true
fmt.Println(b == nil) // false
```

### Reduce Scope of Variables

การลดขอบเขตของตัวแปร (variable scope) ช่วยให้โค้ดอ่านง่ายและเข้าใจง่ายขึ้น โดยควรทำ เมื่อเป็นไปได้ และไม่ขัดแย้งกับหลักการ [Reduce Nesting](#reduce-nesting)

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
err := os.WriteFile(name, data, 0644)
if err != nil {
 return err
}
```

</td><td>

```go
if err := os.WriteFile(name, data, 0644); err != nil {
 return err
}
```

</td></tr>
</tbody></table>

ถ้าคุณจำเป็นต้องใช้ผลลัพธ์จากการเรียกฟังก์ชัน นอกเงื่อนไข if, ไม่ควรลดขอบเขตของตัวแปร เพราะจะทำให้โค้ดอ่านยากขึ้นและมีโครงสร้างซับซ้อนโดยไม่จำเป็น

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
if data, err := os.ReadFile(name); err == nil {
  err = cfg.Decode(data)
  if err != nil {
    return err
  }

  fmt.Println(cfg)
  return nil
} else {
  return err
}
```

</td><td>

```go
data, err := os.ReadFile(name)
if err != nil {
   return err
}

if err := cfg.Decode(data); err != nil {
  return err
}

fmt.Println(cfg)
return nil
```

</td></tr>
</tbody></table>

หลักการ: ค่าคงที่ (constants) ไม่จำเป็นต้องเป็น global หากใช้เฉพาะภายในฟังก์ชันเดียว

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
const (
  _defaultPort = 8080
  _defaultUser = "user"
)

func Bar() {
  fmt.Println("Default port", _defaultPort)
}
```

</td><td>

```go
func Bar() {
  const (
    defaultPort = 8080
    defaultUser = "user"
  )
  fmt.Println("Default port", defaultPort)
}
```

</td></tr>
</tbody></table>

### Avoid Naked Parameters

การส่งพารามิเตอร์แบบเปล่า ๆ ในฟังก์ชัน (โดยไม่มีคำอธิบาย) อาจทำให้ผู้อ่านโค้ดสับสนหรือเข้าใจผิดได้
หากความหมายของพารามิเตอร์ไม่ชัดเจน ควรเพิ่มคอมเมนต์แบบ C (`/* ... */`) เพื่อบอกชื่อพารามิเตอร์

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func printInfo(name string, isLocal, done bool)

printInfo("foo", true, true)
```

</td><td>

```go
// func printInfo(name string, isLocal, done bool)

printInfo("foo", true /* isLocal */, true /* done */)
```

</td></tr>
</tbody></table>

ดียิ่งกว่านั้น: ให้หลีกเลี่ยงการใช้ `bool` แบบเปล่า ๆ โดยการสร้าง custom type ขึ้นมาแทน
เพื่อให้โค้ดอ่านง่ายขึ้นและปลอดภัยจากความผิดพลาดด้าน type
นอกจากนี้ยังสามารถขยายตัวเลือกให้มากกว่าแค่ true/false ได้ในอนาคต

```go
type Region int

const (
  UnknownRegion Region = iota
  Local
)

type Status int

const (
  StatusReady Status = iota + 1
  StatusDone
  // ในอนาคตอาจมีสถานะใหม่เพิ่ม เช่น StatusInProgress
)

func printInfo(name string, region Region, status Status)
```

### Use Raw String Literals to Avoid Escaping

Go supports [raw string literals](https://go.dev/ref/spec#raw_string_lit),
which can span multiple lines and include quotes. Use these to avoid
hand-escaped strings which are much harder to read.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
wantError := "unknown name:\"test\""
```

</td><td>

```go
wantError := `unknown error:"test"`
```

</td></tr>
</tbody></table>

### Initializing Structs

#### Use Field Names to Initialize Structs

You should almost always specify field names when initializing structs. This is
now enforced by [`go vet`](https://pkg.go.dev/cmd/vet).

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
k := User{"John", "Doe", true}
```

</td><td>

```go
k := User{
    FirstName: "John",
    LastName: "Doe",
    Admin: true,
}
```

</td></tr>
</tbody></table>

Exception: Field names *may* be omitted in test tables when there are 3 or
fewer fields.

```go
tests := []struct{
  op Operation
  want string
}{
  {Add, "add"},
  {Subtract, "subtract"},
}
```

#### Omit Zero Value Fields in Structs

When initializing structs with field names, omit fields that have zero values
unless they provide meaningful context. Otherwise, let Go set these to zero
values automatically.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
user := User{
  FirstName: "John",
  LastName: "Doe",
  MiddleName: "",
  Admin: false,
}
```

</td><td>

```go
user := User{
  FirstName: "John",
  LastName: "Doe",
}
```

</td></tr>
</tbody></table>

This helps reduce noise for readers by omitting values that are default in
that context. Only meaningful values are specified.

Include zero values where field names provide meaningful context. For example,
test cases in [Test Tables](#test-tables) can benefit from names of fields
even when they are zero-valued.

```go
tests := []struct{
  give string
  want int
}{
  {give: "0", want: 0},
  // ...
}
```

#### Use `var` for Zero Value Structs

When all the fields of a struct are omitted in a declaration, use the `var`
form to declare the struct.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
user := User{}
```

</td><td>

```go
var user User
```

</td></tr>
</tbody></table>

This differentiates zero valued structs from those with non-zero fields
similar to the distinction created for [map initialization](#initializing-maps), and matches how
we prefer to [declare empty slices](https://go.dev/wiki/CodeReviewComments#declaring-empty-slices).

#### Initializing Struct References

Use `&T{}` instead of `new(T)` when initializing struct references so that it
is consistent with the struct initialization.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
sval := T{Name: "foo"}

// inconsistent
sptr := new(T)
sptr.Name = "bar"
```

</td><td>

```go
sval := T{Name: "foo"}

sptr := &T{Name: "bar"}
```

</td></tr>
</tbody></table>

### Initializing Maps

Prefer `make(..)` for empty maps, and maps populated
programmatically. This makes map initialization visually
distinct from declaration, and it makes it easy to add size
hints later if available.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var (
  // m1 is safe to read and write;
  // m2 will panic on writes.
  m1 = map[T1]T2{}
  m2 map[T1]T2
)
```

</td><td>

```go
var (
  // m1 is safe to read and write;
  // m2 will panic on writes.
  m1 = make(map[T1]T2)
  m2 map[T1]T2
)
```

</td></tr>
<tr><td>

Declaration and initialization are visually similar.

</td><td>

Declaration and initialization are visually distinct.

</td></tr>
</tbody></table>

Where possible, provide capacity hints when initializing
maps with `make()`. See
[Specifying Map Capacity Hints](#specifying-map-capacity-hints)
for more information.

On the other hand, if the map holds a fixed list of elements,
use map literals to initialize the map.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
m := make(map[T1]T2, 3)
m[k1] = v1
m[k2] = v2
m[k3] = v3
```

</td><td>

```go
m := map[T1]T2{
  k1: v1,
  k2: v2,
  k3: v3,
}
```

</td></tr>
</tbody></table>

The basic rule of thumb is to use map literals when adding a fixed set of
elements at initialization time, otherwise use `make` (and specify a size hint
if available).

### Format Strings outside Printf

If you declare format strings for `Printf`-style functions outside a string
literal, make them `const` values.

This helps `go vet` perform static analysis of the format string.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
msg := "unexpected values %v, %v\n"
fmt.Printf(msg, 1, 2)
```

</td><td>

```go
const msg = "unexpected values %v, %v\n"
fmt.Printf(msg, 1, 2)
```

</td></tr>
</tbody></table>

### Naming Printf-style Functions

When you declare a `Printf`-style function, make sure that `go vet` can detect
it and check the format string.

This means that you should use predefined `Printf`-style function
names if possible. `go vet` will check these by default. See [Printf family](https://pkg.go.dev/cmd/vet#hdr-Printf_family)
for more information.

If using the predefined names is not an option, end the name you choose with
f: `Wrapf`, not `Wrap`. `go vet` can be asked to check specific `Printf`-style
names but they must end with f.

```shell
go vet -printfuncs=wrapf,statusf
```

See also [go vet: Printf family check](https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/).

## Patterns

### Test Tables

Table-driven tests with [subtests](https://go.dev/blog/subtests) can be a helpful pattern for writing tests
to avoid duplicating code when the core test logic is repetitive.

If a system under test needs to be tested against *multiple conditions* where
certain parts of the the inputs and outputs change, a table-driven test should
be used to reduce redundancy and improve readability.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func TestSplitHostPort(t *testing.T)

host, port, err := net.SplitHostPort("192.0.2.0:8000")
require.NoError(t, err)
assert.Equal(t, "192.0.2.0", host)
assert.Equal(t, "8000", port)

host, port, err = net.SplitHostPort("192.0.2.0:http")
require.NoError(t, err)
assert.Equal(t, "192.0.2.0", host)
assert.Equal(t, "http", port)

host, port, err = net.SplitHostPort(":8000")
require.NoError(t, err)
assert.Equal(t, "", host)
assert.Equal(t, "8000", port)

host, port, err = net.SplitHostPort("1:8")
require.NoError(t, err)
assert.Equal(t, "1", host)
assert.Equal(t, "8", port)
```

</td><td>

```go
// func TestSplitHostPort(t *testing.T)

tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  {
    give:     "192.0.2.0:8000",
    wantHost: "192.0.2.0",
    wantPort: "8000",
  },
  {
    give:     "192.0.2.0:http",
    wantHost: "192.0.2.0",
    wantPort: "http",
  },
  {
    give:     ":8000",
    wantHost: "",
    wantPort: "8000",
  },
  {
    give:     "1:8",
    wantHost: "1",
    wantPort: "8",
  },
}

for _, tt := range tests {
  t.Run(tt.give, func(t *testing.T) {
    host, port, err := net.SplitHostPort(tt.give)
    require.NoError(t, err)
    assert.Equal(t, tt.wantHost, host)
    assert.Equal(t, tt.wantPort, port)
  })
}
```

</td></tr>
</tbody></table>

Test tables make it easier to add context to error messages, reduce duplicate
logic, and add new test cases.

We follow the convention that the slice of structs is referred to as `tests`
and each test case `tt`. Further, we encourage explicating the input and output
values for each test case with `give` and `want` prefixes.

```go
tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  // ...
}

for _, tt := range tests {
  // ...
}
```

#### Avoid Unnecessary Complexity in Table Tests

Table tests can be difficult to read and maintain if the subtests contain conditional
assertions or other branching logic. Table tests should **NOT** be used whenever
there needs to be complex or conditional logic inside subtests (i.e. complex logic inside the `for` loop).

Large, complex table tests harm readability and maintainability because test readers may
have difficulty debugging test failures that occur.

Table tests like this should be split into either multiple test tables or multiple
individual `Test...` functions.

Some ideals to aim for are:

* Focus on the narrowest unit of behavior
* Minimize "test depth", and avoid conditional assertions (see below)
* Ensure that all table fields are used in all tests
* Ensure that all test logic runs for all table cases

In this context, "test depth" means "within a given test, the number of
successive assertions that require previous assertions to hold" (similar
to cyclomatic complexity).
Having "shallower" tests means that there are fewer relationships between
assertions and, more importantly, that those assertions are less likely
to be conditional by default.

Concretely, table tests can become confusing and difficult to read if they use multiple branching
pathways (e.g. `shouldError`, `expectCall`, etc.), use many `if` statements for
specific mock expectations (e.g. `shouldCallFoo`), or place functions inside the
table (e.g. `setupMocks func(*FooMock)`).

However, when testing behavior that only
changes based on changed input, it may be preferable to group similar cases
together in a table test to better illustrate how behavior changes across all inputs,
rather than splitting otherwise comparable units into separate tests
and making them harder to compare and contrast.

If the test body is short and straightforward,
it's acceptable to have a single branching pathway for success versus failure cases
with a table field like `shouldErr` to specify error expectations.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func TestComplicatedTable(t *testing.T) {
  tests := []struct {
    give          string
    want          string
    wantErr       error
    shouldCallX   bool
    shouldCallY   bool
    giveXResponse string
    giveXErr      error
    giveYResponse string
    giveYErr      error
  }{
    // ...
  }

  for _, tt := range tests {
    t.Run(tt.give, func(t *testing.T) {
      // setup mocks
      ctrl := gomock.NewController(t)
      xMock := xmock.NewMockX(ctrl)
      if tt.shouldCallX {
        xMock.EXPECT().Call().Return(
          tt.giveXResponse, tt.giveXErr,
        )
      }
      yMock := ymock.NewMockY(ctrl)
      if tt.shouldCallY {
        yMock.EXPECT().Call().Return(
          tt.giveYResponse, tt.giveYErr,
        )
      }

      got, err := DoComplexThing(tt.give, xMock, yMock)

      // verify results
      if tt.wantErr != nil {
        require.EqualError(t, err, tt.wantErr)
        return
      }
      require.NoError(t, err)
      assert.Equal(t, want, got)
    })
  }
}
```

</td><td>

```go
func TestShouldCallX(t *testing.T) {
  // setup mocks
  ctrl := gomock.NewController(t)
  xMock := xmock.NewMockX(ctrl)
  xMock.EXPECT().Call().Return("XResponse", nil)

  yMock := ymock.NewMockY(ctrl)

  got, err := DoComplexThing("inputX", xMock, yMock)

  require.NoError(t, err)
  assert.Equal(t, "want", got)
}

func TestShouldCallYAndFail(t *testing.T) {
  // setup mocks
  ctrl := gomock.NewController(t)
  xMock := xmock.NewMockX(ctrl)

  yMock := ymock.NewMockY(ctrl)
  yMock.EXPECT().Call().Return("YResponse", nil)

  _, err := DoComplexThing("inputY", xMock, yMock)
  assert.EqualError(t, err, "Y failed")
}
```
</td></tr>
</tbody></table>

This complexity makes it more difficult to change, understand, and prove the
correctness of the test.

While there are no strict guidelines, readability and maintainability should
always be top-of-mind when deciding between Table Tests versus separate tests
for multiple inputs/outputs to a system.

#### Parallel Tests

Parallel tests, like some specialized loops (for example, those that spawn
goroutines or capture references as part of the loop body),
must take care to explicitly assign loop variables within the loop's scope to
ensure that they hold the expected values.

```go
tests := []struct{
  give string
  // ...
}{
  // ...
}

for _, tt := range tests {
  tt := tt // for t.Parallel
  t.Run(tt.give, func(t *testing.T) {
    t.Parallel()
    // ...
  })
}
```

In the example above, we must declare a `tt` variable scoped to the loop
iteration because of the use of `t.Parallel()` below.
If we do not do that, most or all tests will receive an unexpected value for
`tt`, or a value that changes as they're running.

<!-- TODO: Explain how to use _test packages. -->

### Functional Options

Functional options is a pattern in which you declare an opaque `Option` type
that records information in some internal struct. You accept a variadic number
of these options and act upon the full information recorded by the options on
the internal struct.

Use this pattern for optional arguments in constructors and other public APIs
that you foresee needing to expand, especially if you already have three or
more arguments on those functions.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// package db

func Open(
  addr string,
  cache bool,
  logger *zap.Logger
) (*Connection, error) {
  // ...
}
```

</td><td>

```go
// package db

type Option interface {
  // ...
}

func WithCache(c bool) Option {
  // ...
}

func WithLogger(log *zap.Logger) Option {
  // ...
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  // ...
}
```

</td></tr>
<tr><td>

The cache and logger parameters must always be provided, even if the user
wants to use the default.

```go
db.Open(addr, db.DefaultCache, zap.NewNop())
db.Open(addr, db.DefaultCache, log)
db.Open(addr, false /* cache */, zap.NewNop())
db.Open(addr, false /* cache */, log)
```

</td><td>

Options are provided only if needed.

```go
db.Open(addr)
db.Open(addr, db.WithLogger(log))
db.Open(addr, db.WithCache(false))
db.Open(
  addr,
  db.WithCache(false),
  db.WithLogger(log),
)
```

</td></tr>
</tbody></table>

Our suggested way of implementing this pattern is with an `Option` interface
that holds an unexported method, recording options on an unexported `options`
struct.

```go
type options struct {
  cache  bool
  logger *zap.Logger
}

type Option interface {
  apply(*options)
}

type cacheOption bool

func (c cacheOption) apply(opts *options) {
  opts.cache = bool(c)
}

func WithCache(c bool) Option {
  return cacheOption(c)
}

type loggerOption struct {
  Log *zap.Logger
}

func (l loggerOption) apply(opts *options) {
  opts.logger = l.Log
}

func WithLogger(log *zap.Logger) Option {
  return loggerOption{Log: log}
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  options := options{
    cache:  defaultCache,
    logger: zap.NewNop(),
  }

  for _, o := range opts {
    o.apply(&options)
  }

  // ...
}
```

Note that there's a method of implementing this pattern with closures but we
believe that the pattern above provides more flexibility for authors and is
easier to debug and test for users. In particular, it allows options to be
compared against each other in tests and mocks, versus closures where this is
impossible. Further, it lets options implement other interfaces, including
`fmt.Stringer` which allows for user-readable string representations of the
options.

See also,

- [Self-referential functions and the design of options](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html)
- [Functional options for friendly APIs](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)

<!-- TODO: replace this with parameter structs and functional options, when to
use one vs other -->

## Linting

More importantly than any "blessed" set of linters, lint consistently across a
codebase.

We recommend using the following linters at a minimum, because we feel that they
help to catch the most common issues and also establish a high bar for code
quality without being unnecessarily prescriptive:

- [errcheck](https://github.com/kisielk/errcheck) to ensure that errors are handled
- [goimports](https://pkg.go.dev/golang.org/x/tools/cmd/goimports) to format code and manage imports
- [golint](https://github.com/golang/lint) to point out common style mistakes
- [govet](https://pkg.go.dev/cmd/vet) to analyze code for common mistakes
- [staticcheck](https://staticcheck.dev) to do various static analysis checks

### Lint Runners

We recommend [golangci-lint](https://github.com/golangci/golangci-lint) as the go-to lint runner for Go code, largely due
to its performance in larger codebases and ability to configure and use many
canonical linters at once. This repo has an example [.golangci.yml](https://github.com/uber-go/guide/blob/master/.golangci.yml) config file
with recommended linters and settings.

golangci-lint has [various linters](https://golangci-lint.run/usage/linters/) available for use. The above linters are
recommended as a base set, and we encourage teams to add any additional linters
that make sense for their projects.